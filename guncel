#!/usr/bin/env bash
#
# ARCB Wider Updater
# GitHub: https://github.com/ahm3t0t/arcb-wider-updater
#

# --- AYARLAR ---
VERSION="5.4.8"
EDITION="BigFive"
CODENAME="Beacon"
LOG_DIR="/var/log/arcb-updater"
LOG_FILE="$LOG_DIR/update_$(date +%Y%m%d_%H%M%S).log"
# v5.4.5: Releases URL kullan (CDN cache sorunu önlenir - raw.githubusercontent.com cache'lenebilir)
GITHUB_RAW_URL="https://github.com/ahm3t0t/arcb-wider-updater/releases/latest/download/guncel"
GITHUB_SHA256_URL="https://github.com/ahm3t0t/arcb-wider-updater/releases/latest/download/SHA256SUMS"
CONFIG_FILE="/etc/arcb-wider-updater.conf"

# STRICT MODE
set -Eeuo pipefail

# PATH: Cron ortamında eksik olabilir
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

# GÜVENLİK: Log ve temp dosyalar sadece root okusun
umask 0077

# Renkler (ANSI-C quoting ile)
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[0;33m'
BLUE=$'\033[0;34m'
BOLD=$'\033[1m'
NC=$'\033[0m'

# --- YENİ: MODLAR VE SAYAÇLAR ---
VERBOSE_MODE=false
QUIET_MODE=false
AUTO_MODE=false
DRY_RUN=false

# --- YENİ v3.6.0: SKIP/ONLY BAYRAKLARI ---
SKIP_SNAPSHOT=false
SKIP_FLATPAK=false
SKIP_SNAP=false
SKIP_FWUPD=false
SKIP_PKG_MANAGER=false
ONLY_MODE=""

# Güncelleme sayaçları - FIX: Ensure they're always numeric
APT_COUNT=0
DNF_COUNT=0
PACMAN_COUNT=0
ZYPPER_COUNT=0
APK_COUNT=0
FLATPAK_COUNT=0
SNAP_COUNT=0
FWUPD_COUNT=0
SNAPSHOT_NAME=""

# --- JSON OUTPUT MOD (v5.3.0) ---
JSON_MODE="none"  # none, json, json-full

# --- JSON DATA COLLECTION ---
declare -a JSON_PACKAGES=()
declare -a JSON_WARNINGS=()
declare -a JSON_ERRORS=()
declare -a JSON_PKG_MANAGERS=()
START_TIME=""

# v3.6.1 FIX: Orijinal argümanları sakla (check_root için)
ORIGINAL_ARGS=("$@")

# --- YENİ v3.6.0: CONFIG DOSYASI YÜKLEME ---
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
        # Config'den gelen değerleri uygula
        VERBOSE_MODE="${CONFIG_VERBOSE:-$VERBOSE_MODE}"
        QUIET_MODE="${CONFIG_QUIET:-$QUIET_MODE}"
        AUTO_MODE="${CONFIG_AUTO:-$AUTO_MODE}"
        SKIP_SNAPSHOT="${CONFIG_SKIP_SNAPSHOT:-$SKIP_SNAPSHOT}"
        SKIP_FLATPAK="${CONFIG_SKIP_FLATPAK:-$SKIP_FLATPAK}"
        SKIP_SNAP="${CONFIG_SKIP_SNAP:-$SKIP_SNAP}"
        SKIP_FWUPD="${CONFIG_SKIP_FWUPD:-$SKIP_FWUPD}"
        SKIP_PKG_MANAGER="${CONFIG_SKIP_PKG_MANAGER:-$SKIP_PKG_MANAGER}"
        # JSON modu (v5.3+)
        JSON_MODE="${CONFIG_JSON_MODE:-$JSON_MODE}"
        # Renk ayarları (opsiyonel)
        RED="${CONFIG_COLOR_RED:-$RED}"
        GREEN="${CONFIG_COLOR_GREEN:-$GREEN}"
        YELLOW="${CONFIG_COLOR_YELLOW:-$YELLOW}"
        BLUE="${CONFIG_COLOR_BLUE:-$BLUE}"
    fi
}

# Config'i yükle (argümanlardan önce, argümanlar override eder)
load_config

# --- TRAP & LOGGING ---
finish_logging() {
    local ec=$?
    if [ -f "$LOG_FILE" ]; then
        echo "[$(date '+%F %T')] INFO: Finished with exit_code=$ec" >> "$LOG_FILE"
    fi
}
trap finish_logging EXIT

print_header() {
    if [[ "$QUIET_MODE" == "true" ]]; then return; fi
    printf '\n%s>>> %s %s\n' "${BLUE}${BOLD}" "$1" "${NC}"
    printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
    echo "[$(date '+%F %T')] >>> $1" >> "$LOG_FILE"
}

print_error() {
    printf '%s[X] HATA: %s %s\n' "${RED}${BOLD}" "$1" "${NC}"
    echo "[$(date '+%F %T')] ERROR: $1" >> "$LOG_FILE"
}

print_warning() {
    if [[ "$QUIET_MODE" == "true" ]]; then
        echo "[$(date '+%F %T')] WARN: $1" >> "$LOG_FILE"
        return
    fi
    printf '%s[!] UYARI: %s %s\n' "${YELLOW}" "$1" "${NC}"
    echo "[$(date '+%F %T')] WARN: $1" >> "$LOG_FILE"
}

print_success() {
    if [[ "$QUIET_MODE" == "true" ]]; then
        echo "[$(date '+%F %T')] SUCCESS: $1" >> "$LOG_FILE"
        return
    fi
    printf '%s[+] %s %s\n' "${GREEN}${BOLD}" "$1" "${NC}"
    echo "[$(date '+%F %T')] SUCCESS: $1" >> "$LOG_FILE"
}

print_info() {
    if [[ "$QUIET_MODE" == "true" ]]; then
        echo "[$(date '+%F %T')] INFO: $1" >> "$LOG_FILE"
        return
    fi
    if [[ "$VERBOSE_MODE" == "true" ]]; then
        printf '%s[i] %s%s\n' "${BLUE}" "$1" "${NC}"
    fi
    echo "[$(date '+%F %T')] INFO: $1" >> "$LOG_FILE"
}

# --- v3.8.0: DRY-RUN MESAJI ---
print_dry_run() {
    [[ "$JSON_MODE" != "none" ]] && { echo "[$(date '+%F %T')] DRY-RUN: $1" >> "$LOG_FILE"; return; }
    printf '%s[DRY-RUN] %s%s\n' "${YELLOW}" "$1" "${NC}"
    echo "[$(date '+%F %T')] DRY-RUN: $1" >> "$LOG_FILE"
}

# --- v5.3.0: JSON OUTPUT HELPER FUNCTIONS ---

# JSON escape fonksiyonu - özel karakterleri escape eder
json_escape() {
    local str="$1"
    str="${str//\\/\\\\}"
    str="${str//\"/\\\"}"
    str="${str//$'\n'/\\n}"
    str="${str//$'\r'/\\r}"
    str="${str//$'\t'/\\t}"
    printf '%s' "$str"
}

# Paket bilgisi ekleme (--json-full için)
add_package_info() {
    local name="$1" from="$2" to="$3" manager="$4"
    JSON_PACKAGES+=("{\"name\":\"$(json_escape "$name")\",\"version_from\":\"$(json_escape "$from")\",\"version_to\":\"$(json_escape "$to")\",\"manager\":\"$manager\"}")
}

# Warning ekleme
add_json_warning() {
    [[ "$JSON_MODE" == "none" ]] && return
    JSON_WARNINGS+=("\"$(json_escape "$1")\"")
}

# Error ekleme
add_json_error() {
    [[ "$JSON_MODE" == "none" ]] && return
    JSON_ERRORS+=("\"$(json_escape "$1")\"")
}

# Package manager status ekleme
add_pkg_manager_status() {
    [[ "$JSON_MODE" == "none" ]] && return
    local name="$1" status="$2" count="${3:-0}" reason="${4:-}"
    if [[ -n "$reason" ]]; then
        JSON_PKG_MANAGERS+=("{\"name\":\"$name\",\"status\":\"$status\",\"reason\":\"$reason\"}")
    else
        JSON_PKG_MANAGERS+=("{\"name\":\"$name\",\"status\":\"$status\",\"updated_count\":$count}")
    fi
}

# Distro bilgisi alma
get_distro_info() {
    local distro="" version=""
    if [[ -f /etc/os-release ]]; then
        distro=$(grep "^ID=" /etc/os-release | cut -d= -f2 | tr -d '"')
        version=$(grep "^VERSION_ID=" /etc/os-release | cut -d= -f2 | tr -d '"')
    fi
    echo "$distro|$version"
}

# --- SİSTEM BİLGİSİ BAŞLIK KUTUSU ---
print_system_header() {
    local hostname_str
    hostname_str=$(hostname 2>/dev/null || echo "unknown")
    local user_str
    user_str=$(whoami 2>/dev/null || echo "unknown")
    local kernel_str
    kernel_str=$(uname -r 2>/dev/null || echo "unknown")
    local ram_str
    ram_str=$(free -h 2>/dev/null | awk '/^Mem:/{print $2}' || echo "N/A")
    local disk_str
    disk_str=$(df -h / 2>/dev/null | awk 'NR==2{print $5}' || echo "N/A")

    # JSON modunda terminal çıktısı bastırılır
    if [[ "$JSON_MODE" == "none" ]]; then
        printf '%s========================================%s\n' "${GREEN}" "${NC}"
        printf '%s  ARCB-WIDER-UPDATER v%s (%s Edition)%s\n' "${GREEN}" "${VERSION}" "${EDITION}" "${NC}"
        [[ "$DRY_RUN" == "true" ]] && printf '%s  [DRY-RUN MODE]%s\n' "${YELLOW}" "${NC}"
        printf '%s  Host: %s | User: %s%s\n' "${GREEN}" "${hostname_str}" "${user_str}" "${NC}"
        printf '%s  Kernel: %s%s\n' "${GREEN}" "${kernel_str}" "${NC}"
        printf '%s  RAM: %s | Disk: %s used%s\n' "${GREEN}" "${ram_str}" "${disk_str}" "${NC}"
        printf '%s========================================%s\n' "${GREEN}" "${NC}"
    fi

    # Log'a da yaz
    {
        echo "=================================================="
        echo "PRE-UPDATE SYSTEM INFO"
        echo "Version    : $VERSION ($EDITION Edition - $CODENAME)"
        echo "Dry-Run    : $DRY_RUN"
        echo "Hostname   : $hostname_str"
        echo "User       : $user_str"
        echo "Kernel     : $kernel_str"
        echo "RAM        : $ram_str"
        echo "Disk Usage : $disk_str"
        echo "=================================================="
    } >> "$LOG_FILE"
}

# --- REBOOT GEREKLİ Mİ KONTROLÜ ---
check_reboot_required() {
    # Debian/Ubuntu: /var/run/reboot-required dosyası
    if [[ -f "/var/run/reboot-required" ]]; then
        echo "Gerekli"
        return
    fi
    
    # Fedora/RHEL: needs-restarting komutu
    if command -v needs-restarting &> /dev/null; then
        if ! needs-restarting -r &> /dev/null; then
            echo "Gerekli"
            return
        fi
    fi
    
    echo "Gerekli değil"
}

# --- FİNAL ÖZET KUTUSU ---
print_final_summary() {
    # JSON modunda terminal çıktısı bastırılır
    [[ "$JSON_MODE" != "none" ]] && return

    local reboot_status
    reboot_status=$(check_reboot_required)

    # FIX: Ensure all counters are numeric - strip any non-numeric chars
    # v5.1: BigFive - apt, dnf, pacman, zypper, apk
    local apt_c dnf_c pacman_c zypper_c apk_c flatpak_c snap_c fwupd_c
    apt_c=$(echo "${APT_COUNT:-0}" | tr -cd '0-9')
    dnf_c=$(echo "${DNF_COUNT:-0}" | tr -cd '0-9')
    pacman_c=$(echo "${PACMAN_COUNT:-0}" | tr -cd '0-9')
    zypper_c=$(echo "${ZYPPER_COUNT:-0}" | tr -cd '0-9')
    apk_c=$(echo "${APK_COUNT:-0}" | tr -cd '0-9')
    flatpak_c=$(echo "${FLATPAK_COUNT:-0}" | tr -cd '0-9')
    snap_c=$(echo "${SNAP_COUNT:-0}" | tr -cd '0-9')
    fwupd_c=$(echo "${FWUPD_COUNT:-0}" | tr -cd '0-9')

    # Default to 0 if empty after stripping
    apt_c=${apt_c:-0}
    dnf_c=${dnf_c:-0}
    pacman_c=${pacman_c:-0}
    zypper_c=${zypper_c:-0}
    apk_c=${apk_c:-0}
    flatpak_c=${flatpak_c:-0}
    snap_c=${snap_c:-0}
    fwupd_c=${fwupd_c:-0}

    local total_updates=$((apt_c + dnf_c + pacman_c + zypper_c + apk_c + flatpak_c + snap_c + fwupd_c))

    echo ""
    printf '%s========================================%s\n' "${GREEN}" "${NC}"
    if [[ "$DRY_RUN" == "true" ]]; then
        printf '%s  [DRY-RUN] GÜNCELLEME ÖNİZLEMESİ%s\n' "${YELLOW}" "${NC}"
    else
        printf '%s  [+] GÜNCELLEME TAMAMLANDI%s\n' "${GREEN}" "${NC}"
    fi
    printf '%s----------------------------------------%s\n' "${GREEN}" "${NC}"
    
    # APT veya DNF
    if command -v apt-get &> /dev/null; then
        if [[ $apt_c -gt 0 ]]; then
            printf '%s  APT: %s paket %s%s\n' "${GREEN}" "${apt_c}" "$([[ "$DRY_RUN" == "true" ]] && echo "güncellenebilir" || echo "güncellendi")" "${NC}"
        else
            printf '%s  APT: Güncel%s\n' "${GREEN}" "${NC}"
        fi
    fi
    
    if command -v dnf &> /dev/null; then
        if [[ $dnf_c -gt 0 ]]; then
            printf '%s  DNF: %s paket %s%s\n' "${GREEN}" "${dnf_c}" "$([[ "$DRY_RUN" == "true" ]] && echo "güncellenebilir" || echo "güncellendi")" "${NC}"
        else
            printf '%s  DNF: Güncel%s\n' "${GREEN}" "${NC}"
        fi
    fi

    # v5.0 BigFour: Pacman
    if command -v pacman &> /dev/null; then
        if [[ $pacman_c -gt 0 ]]; then
            printf '%s  Pacman: %s paket %s%s\n' "${GREEN}" "${pacman_c}" "$([[ "$DRY_RUN" == "true" ]] && echo "güncellenebilir" || echo "güncellendi")" "${NC}"
        else
            printf '%s  Pacman: Güncel%s\n' "${GREEN}" "${NC}"
        fi
    fi

    # v5.0 BigFour: Zypper
    if command -v zypper &> /dev/null; then
        if [[ $zypper_c -gt 0 ]]; then
            printf '%s  Zypper: %s paket %s%s\n' "${GREEN}" "${zypper_c}" "$([[ "$DRY_RUN" == "true" ]] && echo "güncellenebilir" || echo "güncellendi")" "${NC}"
        else
            printf '%s  Zypper: Güncel%s\n' "${GREEN}" "${NC}"
        fi
    fi

    # v5.1 BigFive: APK (Alpine)
    if command -v apk &> /dev/null; then
        if [[ $apk_c -gt 0 ]]; then
            printf '%s  APK: %s paket %s%s\n' "${GREEN}" "${apk_c}" "$([[ "$DRY_RUN" == "true" ]] && echo "güncellenebilir" || echo "güncellendi")" "${NC}"
        else
            printf '%s  APK: Güncel%s\n' "${GREEN}" "${NC}"
        fi
    fi

    # Flatpak
    if command -v flatpak &> /dev/null; then
        if [[ $flatpak_c -gt 0 ]]; then
            printf '%s  Flatpak: %s uygulama %s%s\n' "${GREEN}" "${flatpak_c}" "$([[ "$DRY_RUN" == "true" ]] && echo "güncellenebilir" || echo "güncellendi")" "${NC}"
        else
            printf '%s  Flatpak: Güncel%s\n' "${GREEN}" "${NC}"
        fi
    fi
    
    # Snap
    if command -v snap &> /dev/null; then
        if [[ $snap_c -gt 0 ]]; then
            printf '%s  Snap: %s paket %s%s\n' "${GREEN}" "${snap_c}" "$([[ "$DRY_RUN" == "true" ]] && echo "güncellenebilir" || echo "güncellendi")" "${NC}"
        else
            printf '%s  Snap: Güncel%s\n' "${GREEN}" "${NC}"
        fi
    fi
    
    # Firmware
    if command -v fwupdmgr &> /dev/null; then
        if [[ $fwupd_c -gt 0 ]]; then
            printf '%s  Firmware: %s %s%s\n' "${GREEN}" "${fwupd_c}" "$([[ "$DRY_RUN" == "true" ]] && echo "güncelleme mevcut" || echo "güncelleme")" "${NC}"
        else
            printf '%s  Firmware: Güncel%s\n' "${GREEN}" "${NC}"
        fi
    fi
    
    printf '%s----------------------------------------%s\n' "${GREEN}" "${NC}"
    
    # Snapshot bilgisi
    if [[ -n "$SNAPSHOT_NAME" ]]; then
        printf '%s  Snapshot: %s%s\n' "${GREEN}" "${SNAPSHOT_NAME}" "${NC}"
    elif [[ "$DRY_RUN" == "true" ]]; then
        printf '%s  Snapshot: [DRY-RUN] Oluşturulmayacak%s\n' "${YELLOW}" "${NC}"
    else
        printf '%s  Snapshot: Oluşturulmadı%s\n' "${GREEN}" "${NC}"
    fi
    
    # Reboot durumu
    if [[ "$reboot_status" == "Gerekli" ]]; then
        printf '%s  Reboot: [!] Gerekli%s\n' "${YELLOW}" "${NC}"
    else
        printf '%s  Reboot: Gerekli değil%s\n' "${GREEN}" "${NC}"
    fi
    
    # Log yolu
    printf '%s  Log: %s%s\n' "${BLUE}" "${LOG_FILE}" "${NC}"
    
    printf '%s========================================%s\n' "${GREEN}" "${NC}"
    
    # Log'a da yaz
    {
        echo "=================================================="
        echo "POST-UPDATE SUMMARY"
        echo "Dry-Run: $DRY_RUN"
        echo "Total Updates: $total_updates"
        [[ $apt_c -gt 0 ]] && echo "APT: $apt_c packages"
        [[ $dnf_c -gt 0 ]] && echo "DNF: $dnf_c packages"
        [[ $pacman_c -gt 0 ]] && echo "Pacman: $pacman_c packages"
        [[ $zypper_c -gt 0 ]] && echo "Zypper: $zypper_c packages"
        [[ $apk_c -gt 0 ]] && echo "APK: $apk_c packages"
        [[ $flatpak_c -gt 0 ]] && echo "Flatpak: $flatpak_c apps"
        [[ $snap_c -gt 0 ]] && echo "Snap: $snap_c packages"
        [[ $fwupd_c -gt 0 ]] && echo "Firmware: $fwupd_c updates"
        echo "Snapshot: ${SNAPSHOT_NAME:-None}"
        echo "Reboot Required: $reboot_status"
        echo "=================================================="
    } >> "$LOG_FILE"
}

# --- v5.3.0: JSON OUTPUT FUNCTION ---
output_json() {
    local exit_code="${1:-0}"
    local end_time duration_seconds
    end_time=$(date +%s)
    duration_seconds=$((end_time - START_TIME))

    local status="success"
    [[ $exit_code -ne 0 ]] && status="failure"

    local reboot_req="false"
    [[ "$(check_reboot_required)" == "Gerekli" ]] && reboot_req="true"

    # FIX: Ensure all counters are numeric
    local apt_c dnf_c pacman_c zypper_c apk_c flatpak_c snap_c fwupd_c
    apt_c=$(echo "${APT_COUNT:-0}" | tr -cd '0-9')
    dnf_c=$(echo "${DNF_COUNT:-0}" | tr -cd '0-9')
    pacman_c=$(echo "${PACMAN_COUNT:-0}" | tr -cd '0-9')
    zypper_c=$(echo "${ZYPPER_COUNT:-0}" | tr -cd '0-9')
    apk_c=$(echo "${APK_COUNT:-0}" | tr -cd '0-9')
    flatpak_c=$(echo "${FLATPAK_COUNT:-0}" | tr -cd '0-9')
    snap_c=$(echo "${SNAP_COUNT:-0}" | tr -cd '0-9')
    fwupd_c=$(echo "${FWUPD_COUNT:-0}" | tr -cd '0-9')

    apt_c=${apt_c:-0}
    dnf_c=${dnf_c:-0}
    pacman_c=${pacman_c:-0}
    zypper_c=${zypper_c:-0}
    apk_c=${apk_c:-0}
    flatpak_c=${flatpak_c:-0}
    snap_c=${snap_c:-0}
    fwupd_c=${fwupd_c:-0}

    local total_count=$((apt_c + dnf_c + pacman_c + zypper_c + apk_c + flatpak_c + snap_c + fwupd_c))

    local timestamp
    timestamp=$(date -Iseconds)

    local hostname_str
    hostname_str=$(hostname 2>/dev/null || echo "unknown")

    local dry_run_val="false"
    [[ "$DRY_RUN" == "true" ]] && dry_run_val="true"

    if [[ "$JSON_MODE" == "json" ]]; then
        # Lightweight JSON for monitoring
        cat <<EOF
{
  "version": "$VERSION",
  "status": "$status",
  "exit_code": $exit_code,
  "timestamp": "$timestamp",
  "hostname": "$hostname_str",
  "duration_seconds": $duration_seconds,
  "dry_run": $dry_run_val,
  "updated_count": $total_count,
  "reboot_required": $reboot_req
}
EOF
    elif [[ "$JSON_MODE" == "json-full" ]]; then
        # Full JSON for SIEM/Audit
        local distro distro_ver kernel_str
        IFS='|' read -r distro distro_ver <<< "$(get_distro_info)"
        kernel_str=$(uname -r 2>/dev/null || echo "unknown")

        # Build arrays - join with comma
        local pkg_managers_json="" packages_json="" warnings_json="" errors_json=""

        if [[ ${#JSON_PKG_MANAGERS[@]} -gt 0 ]]; then
            pkg_managers_json=$(IFS=,; echo "${JSON_PKG_MANAGERS[*]}")
        fi
        if [[ ${#JSON_PACKAGES[@]} -gt 0 ]]; then
            packages_json=$(IFS=,; echo "${JSON_PACKAGES[*]}")
        fi
        if [[ ${#JSON_WARNINGS[@]} -gt 0 ]]; then
            warnings_json=$(IFS=,; echo "${JSON_WARNINGS[*]}")
        fi
        if [[ ${#JSON_ERRORS[@]} -gt 0 ]]; then
            errors_json=$(IFS=,; echo "${JSON_ERRORS[*]}")
        fi

        # Snapshot info
        local snapshot_created="false"
        local snapshot_name_val="null"
        local snapshot_tool_val="null"
        if [[ -n "$SNAPSHOT_NAME" ]]; then
            snapshot_created="true"
            snapshot_name_val="\"$SNAPSHOT_NAME\""
            if command -v timeshift &>/dev/null; then
                snapshot_tool_val="\"timeshift\""
            elif command -v snapper &>/dev/null; then
                snapshot_tool_val="\"snapper\""
            fi
        fi

        cat <<EOF
{
  "version": "$VERSION",
  "status": "$status",
  "exit_code": $exit_code,
  "timestamp": "$timestamp",
  "hostname": "$hostname_str",
  "duration_seconds": $duration_seconds,
  "dry_run": $dry_run_val,
  "reboot_required": $reboot_req,
  "system": {
    "distro": "$distro",
    "distro_version": "$distro_ver",
    "kernel": "$kernel_str"
  },
  "package_managers": [${pkg_managers_json:-}],
  "packages": [${packages_json:-}],
  "snapshot": {
    "created": $snapshot_created,
    "name": $snapshot_name_val,
    "tool": $snapshot_tool_val
  },
  "warnings": [${warnings_json:-}],
  "errors": [${errors_json:-}]
}
EOF
    fi
}

setup_logging() {
    if [ ! -d "$LOG_DIR" ]; then
        mkdir -p "$LOG_DIR"
    fi

    local deleted_count
    # Logrotate handles log cleanup now
    # deleted_count=$(find "$LOG_DIR" -name "update_*.log" -type f -mtime +30 -print -delete | wc -l)
    deleted_count=0
    
    touch "$LOG_FILE"
    chmod 600 "$LOG_FILE"
    
    {
        echo "=================================================="
        echo "ARCB Wider Updater v$VERSION ($EDITION Edition - $CODENAME)"
        echo "Start Time : $(date '+%F %T')"
        echo "User       : $(whoami)"
        echo "Hostname   : $(hostname 2>/dev/null || echo "unknown")"
        echo "Mode       : $([[ "${AUTO_MODE:-false}" == "true" ]] && echo "AUTO" || echo "INTERACTIVE")"
        echo "Dry-Run    : $DRY_RUN"
        echo "Verbose    : $VERBOSE_MODE"
        echo "Quiet      : $QUIET_MODE"
        echo "Skip       : snapshot=$SKIP_SNAPSHOT flatpak=$SKIP_FLATPAK snap=$SKIP_SNAP fwupd=$SKIP_FWUPD pkg_manager=$SKIP_PKG_MANAGER"
        echo "Only Mode  : ${ONLY_MODE:-none}"
        echo "=================================================="
        if [[ "$deleted_count" -gt 0 ]]; then
            echo "INFO: $deleted_count adet eski log dosyası temizlendi."
        fi
    } >> "$LOG_FILE"
}

download_file() {
    local url="$1"
    local output="$2"

    # TLS 1.2+ zorunlu (güvenlik için)
    if command -v curl &> /dev/null; then
        curl --proto '=https' --tlsv1.2 -fsSL "$url" -o "$output"
    elif command -v wget &> /dev/null; then
        wget --secure-protocol=TLSv1_2 -qO "$output" "$url"
    else
        print_error "Sistemde 'curl' veya 'wget' bulunamadı!"
        exit 1
    fi
}

check_connectivity() {
    if [[ "$QUIET_MODE" != "true" ]]; then
        printf '%s[~] Bağlantı kontrol ediliyor... %s' "${YELLOW}" "${NC}"
    fi
    local UA="Mozilla/5.0 (compat; ARCBUpdater/$VERSION)"
    
    local raw_ok=false
    # TLS 1.2+ zorunlu (güvenlik için)
    if command -v curl &> /dev/null; then
        if curl --proto '=https' --tlsv1.2 -s -I -f -L -A "$UA" "$GITHUB_RAW_URL" > /dev/null; then raw_ok=true; fi
    elif command -v wget &> /dev/null; then
        if wget --secure-protocol=TLSv1_2 -q --spider --user-agent="$UA" "$GITHUB_RAW_URL"; then raw_ok=true; fi
    fi
    
    if [[ "$raw_ok" == "true" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            printf '%sBağlı.%s\n' "${GREEN}" "${NC}"
        fi
        return 0
    else
        if [[ "$QUIET_MODE" != "true" ]]; then
            printf '%sKısmi (Repo erişimi yok).%s\n' "${YELLOW}" "${NC}"
        fi
        print_warning "Repo dosyalarına erişilemiyor. Self-update devre dışı."
        export SELF_UPDATE_DISABLED="true"
        return 0
    fi
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        printf '%s[*] Root yetkisi gerekiyor...%s\n' "${YELLOW}" "${NC}"
        if command -v sudo &> /dev/null; then
            # v3.6.1 FIX: Orijinal argümanları kullan
            exec sudo -E "$0" "${ORIGINAL_ARGS[@]}"
        else
            print_error "Sudo yok ve root değilsin."
            exit 1
        fi
    fi
}

# --- YENİ v3.6.0: SHA256 DOĞRULAMA İLE SELF-UPDATE ---
check_self_update() {
    if [[ "${SELF_UPDATE_DISABLED:-false}" == "true" ]]; then return; fi
    if [[ "$DRY_RUN" == "true" ]]; then return; fi

    local REMOTE_FILE; REMOTE_FILE="$(mktemp /tmp/guncel_remote_XXXXXX)"
    local TEMP_SHA256; TEMP_SHA256="$(mktemp /tmp/guncel_sha256_XXXXXX)"
    local REMOTE_HASH
    local LOCAL_HASH
    
    # Cleanup on exit
    trap 'rm -f "$REMOTE_FILE" "$TEMP_SHA256"' RETURN
    
    if ! download_file "$GITHUB_RAW_URL" "$REMOTE_FILE"; then return; fi

    if ! grep -q "ARCB Wider Updater" "$REMOTE_FILE"; then
        rm -f "$REMOTE_FILE" "$TEMP_SHA256"
        return
    fi

    REMOTE_HASH=$(sha256sum "$REMOTE_FILE" | awk '{print $1}')
    LOCAL_HASH=$(sha256sum "$0" | awk '{print $1}')

    if [[ "$REMOTE_HASH" != "$LOCAL_HASH" && -n "$REMOTE_HASH" ]]; then
        printf '\n%s[!] Yeni sürüm mevcut!%s\n' "${YELLOW}" "${NC}"
        
        # SHA256 doğrulama (v3.6.0)
        if download_file "$GITHUB_SHA256_URL" "$TEMP_SHA256" 2>/dev/null; then
            local EXPECTED
            # v5.4.4 FIX: Sadece "guncel" dosyasını yakala (guncel.bash, guncel.8 değil)
            EXPECTED=$(grep -E "  guncel$" "$TEMP_SHA256" 2>/dev/null | awk '{print $1}')
            if [[ -n "$EXPECTED" && "$EXPECTED" != "$REMOTE_HASH" ]]; then
                print_error "SHA256 doğrulama başarısız! Güncelleme iptal edildi."
                echo "[$(date '+%F %T')] ERROR: SHA256 mismatch - Expected: $EXPECTED, Got: $REMOTE_HASH" >> "$LOG_FILE"
                return 1
            fi
            if [[ -n "$EXPECTED" ]]; then
                print_info "SHA256 doğrulama başarılı."
            fi
        else
            print_warning "SHA256SUMS dosyası bulunamadı, doğrulama atlanıyor."
        fi
        
        if [[ "${AUTO_MODE:-false}" == "true" ]]; then
             REPLY="e"
        else
             read -p "   Güncellemek ister misin? (e/H): " -n 1 -r
             echo
        fi

        if [[ ${REPLY:-H} =~ ^[Ee]$ ]]; then
            print_header "Self-Update Başlatılıyor..."
            
            # v3.6.0: .bak yedek mekanizması
            if [ -f "$0" ]; then
                if cp "$0" "${0}.bak"; then
                    print_info "Eski sürüm yedeklendi: ${0}.bak"
                else
                    print_warning "Yedek oluşturulamadı, devam ediliyor."
                fi
            fi
            
            if install -m 0755 "$REMOTE_FILE" "$0"; then
                print_success "Script güncellendi. Yeniden başlatılıyor..."
                exec "$0" "${ORIGINAL_ARGS[@]}"
            else
                print_error "Güncelleme kopyalanamadı!"
                # Rollback attempt
                if [ -f "${0}.bak" ]; then
                    print_warning "Yedekten geri yükleme deneniyor..."
                    cp "${0}.bak" "$0" && print_success "Geri yükleme başarılı."
                fi
                exit 1
            fi
        fi
    fi
    rm -f "$REMOTE_FILE" "$TEMP_SHA256"
}

wait_for_lock() {
    local has_checker="false"
    if command -v fuser &> /dev/null; then has_checker="fuser";
    elif command -v lsof &> /dev/null; then has_checker="lsof"; fi

    if [[ "$has_checker" == "false" ]]; then return; fi

    local max_retries=15
    local count=0
    local lock_files=("/var/lib/dpkg/lock" "/var/lib/dpkg/lock-frontend" "/var/lib/apt/lists/lock" "/var/cache/apt/archives/lock")
    
    while true; do
        local locked=false
        for lock in "${lock_files[@]}"; do
            if [[ "$has_checker" == "fuser" ]]; then
                if fuser "$lock" >/dev/null 2>&1; then locked=true; break; fi
            elif [[ "$has_checker" == "lsof" ]]; then
                if lsof "$lock" >/dev/null 2>&1; then locked=true; break; fi
            fi
        done

        if [[ "$locked" == "false" ]]; then break; fi

        if [ $count -ge $max_retries ]; then
            print_error "APT kilitleri kaldırılamadı. Manuel müdahale gerek."
            exit 1
        fi
        
        printf '%s[~] APT kilitli (%s), bekleniyor... (%s/%s)%s\n' "${YELLOW}" "$has_checker" "$count" "$max_retries" "${NC}"
        sleep 5
        ((count++))
    done
}

wait_for_dnf_lock() {
    local max_attempts=30
    local attempt=0
    while [ $attempt -lt $max_attempts ]; do
        if ! pgrep -x dnf >/dev/null && ! pgrep -x yum >/dev/null && ! pgrep -x rpm >/dev/null; then
            return 0
        fi
        print_warning "DNF kilidi bekleniyor... ($((attempt+1))/$max_attempts)"
        sleep 10
        ((attempt++))
    done
    print_error "DNF kilidi zaman aşımı!"
    return 1
}

create_snapshot() {
    # v5.4.8: Snapshot timeout (5 dakika varsayılan)
    local SNAPSHOT_TIMEOUT=${CONFIG_SNAPSHOT_TIMEOUT:-300}

    # v3.6.0: --skip snapshot kontrolü
    if [[ "$SKIP_SNAPSHOT" == "true" ]]; then
        print_info "Snapshot atlandı (--skip snapshot)"
        return
    fi

    # v3.6.0: --only kontrolü (system veya fwupd ise snapshot atla)
    if [[ -n "$ONLY_MODE" && "$ONLY_MODE" != "snapshot" ]]; then
        return
    fi

    # v3.8.0: Dry-run modunda snapshot oluşturma
    if [[ "$DRY_RUN" == "true" ]]; then
        if command -v timeshift &> /dev/null; then
            print_dry_run "Timeshift snapshot oluşturulacak: ARCB-Update-$(date +%F)"
        elif command -v snapper &> /dev/null; then
            print_dry_run "Snapper snapshot oluşturulacak: ARCB-Update-$(date +%F)"
        else
            print_dry_run "Yedekleme aracı (Timeshift/Snapper) bulunamadı"
        fi
        return
    fi

    if command -v timeshift &> /dev/null; then
        print_header "Sistem Yedekleniyor (Timeshift)"
        SNAPSHOT_NAME="ARCB-Update-$(date +%F)"
        local ts_exit_code=0
        if [[ "$VERBOSE_MODE" == "true" ]]; then
            timeout "$SNAPSHOT_TIMEOUT" timeshift --create --comments "$SNAPSHOT_NAME" --tags D 2>&1 | tee -a "$LOG_FILE" || ts_exit_code=$?
        else
            timeout "$SNAPSHOT_TIMEOUT" timeshift --create --comments "$SNAPSHOT_NAME" --tags D >> "$LOG_FILE" 2>&1 || ts_exit_code=$?
        fi
        if [[ $ts_exit_code -eq 124 ]]; then
            print_warning "Timeshift snapshot zaman aşımına uğradı (${SNAPSHOT_TIMEOUT}s)"
            add_json_warning "Timeshift snapshot timed out after ${SNAPSHOT_TIMEOUT}s"
            SNAPSHOT_NAME=""
        elif [[ $ts_exit_code -eq 0 ]]; then
            print_success "Timeshift snapshot oluşturuldu."
        else
            print_warning "Timeshift snapshot başarısız oldu (exit: $ts_exit_code)"
            add_json_warning "Timeshift snapshot failed with exit code $ts_exit_code"
            SNAPSHOT_NAME=""
        fi
        return
    fi

    if command -v snapper &> /dev/null; then
        print_header "Sistem Yedekleniyor (Snapper)"
        SNAPSHOT_NAME="ARCB-Update-$(date +%F)"
        local sn_exit_code=0
        timeout "$SNAPSHOT_TIMEOUT" snapper create --description "$SNAPSHOT_NAME" --cleanup-algorithm number >> "$LOG_FILE" 2>&1 || sn_exit_code=$?
        if [[ $sn_exit_code -eq 124 ]]; then
            print_warning "Snapper snapshot zaman aşımına uğradı (${SNAPSHOT_TIMEOUT}s)"
            add_json_warning "Snapper snapshot timed out after ${SNAPSHOT_TIMEOUT}s"
            SNAPSHOT_NAME=""
        elif [[ $sn_exit_code -eq 0 ]]; then
            print_success "Snapper snapshot oluşturuldu."
        else
            print_warning "Snapper snapshot oluşturulamadı."
            SNAPSHOT_NAME=""
        fi
        return
    fi
    
    if [[ "${AUTO_MODE:-false}" != "true" ]]; then
         echo "[$(date '+%F %T')] INFO: Yedekleme aracı (Timeshift/Snapper) yok." >> "$LOG_FILE"
    fi
}

# --- YENİ v3.6.0: ONLY MODE KONTROLÜ ---
should_run_backend() {
    local backend="$1"

    # Eğer --only belirtilmişse, sadece o backend çalışsın
    if [[ -n "$ONLY_MODE" ]]; then
        IFS=',' read -ra ONLY_ITEMS <<< "$ONLY_MODE"
        for item in "${ONLY_ITEMS[@]}"; do
            # v5.1: system = apt, dnf, pacman, zypper, apk (BigFive)
            if [[ "$item" == "$backend" || "$item" == "system" && ("$backend" == "apt" || "$backend" == "dnf" || "$backend" == "pacman" || "$backend" == "zypper" || "$backend" == "apk") ]]; then
                return 0
            fi
        done
        return 1
    fi

    return 0
}

# --- v4.1.0: MODÜLER GÜNCELLEME FONKSİYONLARI ---

# APT Güncellemesi
update_apt() {
    if ! command -v apt-get &> /dev/null; then return 1; fi
    if [[ "$SKIP_PKG_MANAGER" == "true" ]]; then return 1; fi
    if ! should_run_backend "apt"; then return 1; fi

    local apt_opts=()
    if [[ "${AUTO_MODE:-false}" == "true" ]]; then
        export DEBIAN_FRONTEND=noninteractive
        apt_opts=(-o "Dpkg::Options::=--force-confdef" -o "Dpkg::Options::=--force-confold")
    fi

    wait_for_lock
    print_header "APT: Güncelleme Başlıyor"

    if [[ "$VERBOSE_MODE" == "true" ]]; then
        apt-get update 2>&1 | tee -a "$LOG_FILE"
    else
        apt-get update >> "$LOG_FILE" 2>&1
    fi

    print_header "APT: Dist-Upgrade"
    local apt_upgradable apt_simulate
    apt_simulate=$(apt-get -s dist-upgrade 2>/dev/null | grep "^Inst " || true)
    apt_upgradable=$(echo "$apt_simulate" | grep -c "^Inst " || echo "0")
    APT_COUNT=${apt_upgradable:-0}

    # --json-full için paket detaylarını topla
    if [[ "$JSON_MODE" == "json-full" && -n "$apt_simulate" ]]; then
        while IFS= read -r line; do
            local pkg_name old_ver new_ver
            pkg_name=$(echo "$line" | awk '{print $2}')
            old_ver=$(echo "$line" | grep -oP '\[\K[^\]]+' || echo "new")
            new_ver=$(echo "$line" | grep -oP '\(\K[^\s]+' || echo "unknown")
            add_package_info "$pkg_name" "$old_ver" "$new_ver" "apt"
        done <<< "$apt_simulate"
    fi

    if [[ "$VERBOSE_MODE" == "true" ]]; then
        apt-get dist-upgrade -y "${apt_opts[@]}" 2>&1 | tee -a "$LOG_FILE"
    else
        apt-get dist-upgrade -y "${apt_opts[@]}" >> "$LOG_FILE" 2>&1
    fi

    print_header "APT: Temizlik"
    if [[ "$VERBOSE_MODE" == "true" ]]; then
        apt-get autoremove -y "${apt_opts[@]}" 2>&1 | tee -a "$LOG_FILE"
        apt-get autoclean -y "${apt_opts[@]}" 2>&1 | tee -a "$LOG_FILE"
    else
        apt-get autoremove -y "${apt_opts[@]}" >> "$LOG_FILE" 2>&1
        apt-get autoclean -y "${apt_opts[@]}" >> "$LOG_FILE" 2>&1
    fi

    print_info "APT: $APT_COUNT paket güncellendi."
    add_pkg_manager_status "apt" "ran" "$APT_COUNT"
    return 0
}

# DNF Güncellemesi
update_dnf() {
    if ! command -v dnf &> /dev/null; then return 1; fi
    if [[ "$SKIP_PKG_MANAGER" == "true" ]]; then return 1; fi
    if ! should_run_backend "dnf"; then return 1; fi

    if ! wait_for_dnf_lock; then
        print_error "DNF kilidi alınamadı, DNF güncellemesi atlanıyor."
        return 1
    fi

    print_header "DNF: Güncelleme"

    # --json-full için paket detaylarını ÖNCE topla
    if [[ "$JSON_MODE" == "json-full" ]]; then
        local dnf_updates
        dnf_updates=$(dnf check-update 2>/dev/null | awk 'NF>=2 && /^[a-zA-Z0-9]/ {print $1, $2}' || true)
        if [[ -n "$dnf_updates" ]]; then
            while IFS= read -r line; do
                local pkg_full pkg_name new_ver old_ver
                pkg_full=$(echo "$line" | awk '{print $1}')
                new_ver=$(echo "$line" | awk '{print $2}')
                # Paket adından .arch kısmını çıkar
                pkg_name=${pkg_full%.*}
                # Mevcut versiyonu al
                old_ver=$(rpm -q --qf '%{VERSION}-%{RELEASE}' "$pkg_name" 2>/dev/null || echo "unknown")
                add_package_info "$pkg_name" "$old_ver" "$new_ver" "dnf"
            done <<< "$dnf_updates"
        fi
    fi

    local dnf_temp
    dnf_temp=$(mktemp)

    if [[ "$VERBOSE_MODE" == "true" ]]; then
        dnf upgrade --refresh -y 2>&1 | tee -a "$LOG_FILE" | tee "$dnf_temp"
    else
        dnf upgrade --refresh -y 2>&1 | tee "$dnf_temp" >> "$LOG_FILE"
    fi

    # DNF sayacını parse et - v5.4.7 FIX: DNF5 formatı desteği
    # Önce Transaction Summary'den "Upgrading: X packages" satırını dene
    DNF_COUNT=$(grep -oP "Upgrading:\s+\K\d+" "$dnf_temp" 2>/dev/null | head -1 || echo "0")
    # DNF4 fallback: "Upgraded: X" satırı
    if [[ -z "$DNF_COUNT" || "$DNF_COUNT" == "0" ]]; then
        DNF_COUNT=$(grep -oP "Upgraded\s+\K\d+" "$dnf_temp" 2>/dev/null | head -1 || echo "0")
    fi
    # Son fallback: Upgrading satırlarını say (her paket için bir satır)
    if [[ -z "$DNF_COUNT" || "$DNF_COUNT" == "0" ]]; then
        DNF_COUNT=$(grep -cE "^\[.*/.*\] Upgrading " "$dnf_temp" 2>/dev/null || echo "0")
    fi

    rm -f "$dnf_temp"
    DNF_COUNT=${DNF_COUNT:-0}

    print_info "DNF: $DNF_COUNT paket güncellendi."
    add_pkg_manager_status "dnf" "ran" "$DNF_COUNT"
    return 0
}

# Pacman Güncellemesi (v5.0 BigFour - Arch Linux, Manjaro, EndeavourOS)
update_pacman() {
    if ! command -v pacman &> /dev/null; then return 1; fi
    if [[ "$SKIP_PKG_MANAGER" == "true" ]]; then return 1; fi
    if ! should_run_backend "pacman"; then return 1; fi

    print_header "Pacman: Güncelleme"

    local pacman_temp
    pacman_temp=$(mktemp)

    # Önce veritabanını güncelle
    if [[ "$VERBOSE_MODE" == "true" ]]; then
        pacman -Sy 2>&1 | tee -a "$LOG_FILE"
    else
        pacman -Sy >> "$LOG_FILE" 2>&1
    fi

    # Güncellenecek paket sayısını al
    local pacman_updates
    pacman_updates=$(pacman -Qu 2>/dev/null || true)
    PACMAN_COUNT=$(echo "$pacman_updates" | grep -c . || echo "0")
    PACMAN_COUNT=${PACMAN_COUNT:-0}

    # --json-full için paket detaylarını topla
    if [[ "$JSON_MODE" == "json-full" && -n "$pacman_updates" ]]; then
        while IFS= read -r line; do
            local pkg_name old_ver new_ver
            # Format: paket_adı eski_versiyon -> yeni_versiyon
            pkg_name=$(echo "$line" | awk '{print $1}')
            old_ver=$(echo "$line" | awk '{print $2}')
            new_ver=$(echo "$line" | awk '{print $4}')
            add_package_info "$pkg_name" "$old_ver" "$new_ver" "pacman"
        done <<< "$pacman_updates"
    fi

    if [[ "$PACMAN_COUNT" -gt 0 ]]; then
        if [[ "$VERBOSE_MODE" == "true" ]]; then
            pacman -Su --noconfirm 2>&1 | tee -a "$LOG_FILE" | tee "$pacman_temp"
        else
            pacman -Su --noconfirm 2>&1 | tee "$pacman_temp" >> "$LOG_FILE"
        fi
    fi

    rm -f "$pacman_temp"

    # Orphan paketleri temizle (opsiyonel)
    local orphans
    orphans=$(pacman -Qtdq 2>/dev/null || true)
    if [[ -n "$orphans" ]]; then
        print_header "Pacman: Orphan Temizliği"
        if [[ "$VERBOSE_MODE" == "true" ]]; then
            echo "$orphans" | xargs pacman -Rns --noconfirm 2>&1 | tee -a "$LOG_FILE" || true
        else
            echo "$orphans" | xargs pacman -Rns --noconfirm >> "$LOG_FILE" 2>&1 || true
        fi
    fi

    # Cache temizliği
    if command -v paccache &> /dev/null; then
        paccache -r >> "$LOG_FILE" 2>&1 || true
    fi

    print_info "Pacman: $PACMAN_COUNT paket güncellendi."
    add_pkg_manager_status "pacman" "ran" "$PACMAN_COUNT"
    return 0
}

# Zypper Güncellemesi (v5.0 BigFour - openSUSE Leap/Tumbleweed)
update_zypper() {
    if ! command -v zypper &> /dev/null; then return 1; fi
    if [[ "$SKIP_PKG_MANAGER" == "true" ]]; then return 1; fi
    if ! should_run_backend "zypper"; then return 1; fi

    print_header "Zypper: Güncelleme"

    local zypper_temp
    zypper_temp=$(mktemp)

    # Repo'ları yenile
    if [[ "$VERBOSE_MODE" == "true" ]]; then
        zypper refresh 2>&1 | tee -a "$LOG_FILE"
    else
        zypper refresh >> "$LOG_FILE" 2>&1
    fi

    # Güncellenecek paket sayısını al - v5.4.7 FIX: Doğru parsing
    # zypper lu çıktısı: "S | Repository | Name | Current | Available | Arch"
    # Header ve separator satırlarını atla, sadece paket satırlarını say
    local zypper_updates
    zypper_updates=$(zypper -q lu 2>/dev/null | grep -v "^-" | grep -v "^S " | grep "|" || true)
    ZYPPER_COUNT=$(echo "$zypper_updates" | grep -c "|" || echo "0")
    ZYPPER_COUNT=${ZYPPER_COUNT:-0}

    # --json-full için paket detaylarını topla
    if [[ "$JSON_MODE" == "json-full" && -n "$zypper_updates" ]]; then
        while IFS= read -r line; do
            local pkg_name old_ver new_ver
            # Format: S | Repository | Name | Current | Available | Arch
            pkg_name=$(echo "$line" | awk -F'|' '{gsub(/^[ \t]+|[ \t]+$/, "", $3); print $3}')
            old_ver=$(echo "$line" | awk -F'|' '{gsub(/^[ \t]+|[ \t]+$/, "", $4); print $4}')
            new_ver=$(echo "$line" | awk -F'|' '{gsub(/^[ \t]+|[ \t]+$/, "", $5); print $5}')
            [[ -n "$pkg_name" ]] && add_package_info "$pkg_name" "$old_ver" "$new_ver" "zypper"
        done <<< "$zypper_updates"
    fi

    # Güncelleme yap
    if [[ "$VERBOSE_MODE" == "true" ]]; then
        zypper --non-interactive update 2>&1 | tee -a "$LOG_FILE" | tee "$zypper_temp"
    else
        zypper --non-interactive update 2>&1 | tee "$zypper_temp" >> "$LOG_FILE"
    fi

    # Zypper çıktısından sayı parse et (alternatif)
    if [[ "$ZYPPER_COUNT" == "0" ]]; then
        ZYPPER_COUNT=$(grep -cE "^Installing:|^Upgrading:" "$zypper_temp" 2>/dev/null || echo "0")
    fi

    rm -f "$zypper_temp"
    ZYPPER_COUNT=${ZYPPER_COUNT:-0}

    # Kullanılmayan bağımlılıkları temizle
    print_header "Zypper: Temizlik"
    if [[ "$VERBOSE_MODE" == "true" ]]; then
        zypper --non-interactive packages --orphaned 2>&1 | tee -a "$LOG_FILE" || true
    else
        zypper --non-interactive packages --orphaned >> "$LOG_FILE" 2>&1 || true
    fi

    print_info "Zypper: $ZYPPER_COUNT paket güncellendi."
    add_pkg_manager_status "zypper" "ran" "$ZYPPER_COUNT"
    return 0
}

# APK Güncellemesi (v5.1 BigFive - Alpine Linux)
update_apk() {
    if ! command -v apk &> /dev/null; then return 1; fi
    if [[ "$SKIP_PKG_MANAGER" == "true" ]]; then return 1; fi
    if ! should_run_backend "apk"; then return 1; fi

    print_header "APK: Güncelleme"

    # Repo'ları güncelle
    if [[ "$VERBOSE_MODE" == "true" ]]; then
        apk update 2>&1 | tee -a "$LOG_FILE"
    else
        apk update >> "$LOG_FILE" 2>&1
    fi

    # Güncellenecek paket sayısını al
    local apk_updates
    apk_updates=$(apk version -l '<' 2>/dev/null || true)
    APK_COUNT=$(echo "$apk_updates" | grep -c . || echo "0")
    APK_COUNT=${APK_COUNT:-0}

    # --json-full için paket detaylarını topla
    if [[ "$JSON_MODE" == "json-full" && -n "$apk_updates" ]]; then
        while IFS= read -r line; do
            local pkg_with_ver old_ver new_ver pkg_name
            # Format: paket_adı-eski_versiyon < yeni_versiyon
            pkg_with_ver=$(echo "$line" | awk '{print $1}')
            new_ver=$(echo "$line" | awk '{print $3}')
            # Paket adını ve versiyonu ayır (son - karakterinden böl)
            pkg_name=${pkg_with_ver%-*}
            old_ver=${pkg_with_ver##*-}
            [[ -n "$pkg_name" ]] && add_package_info "$pkg_name" "$old_ver" "$new_ver" "apk"
        done <<< "$apk_updates"
    fi

    # Güncelleme yap
    if [[ "$VERBOSE_MODE" == "true" ]]; then
        apk upgrade 2>&1 | tee -a "$LOG_FILE"
    else
        apk upgrade >> "$LOG_FILE" 2>&1
    fi

    # Cache temizliği
    if [[ "$VERBOSE_MODE" == "true" ]]; then
        apk cache clean 2>&1 | tee -a "$LOG_FILE" || true
    else
        apk cache clean >> "$LOG_FILE" 2>&1 || true
    fi

    print_info "APK: $APK_COUNT paket güncellendi."
    add_pkg_manager_status "apk" "ran" "$APK_COUNT"
    return 0
}

# Flatpak Güncellemesi
update_flatpak() {
    if ! command -v flatpak &> /dev/null; then return 1; fi
    if [[ "$SKIP_FLATPAK" == "true" ]]; then return 1; fi
    if ! should_run_backend "flatpak"; then return 1; fi

    print_header "Flatpak: Güncelleme"

    local flatpak_updates flatpak_upgradable
    flatpak_updates=$(flatpak remote-ls --updates --columns=application,version 2>/dev/null || true)
    flatpak_upgradable=$(echo "$flatpak_updates" | grep -c . | tr -cd '0-9')
    flatpak_upgradable=${flatpak_upgradable:-0}

    # --json-full için paket detaylarını topla
    if [[ "$JSON_MODE" == "json-full" && -n "$flatpak_updates" ]]; then
        while IFS= read -r line; do
            local app_id new_ver old_ver
            app_id=$(echo "$line" | awk '{print $1}')
            new_ver=$(echo "$line" | awk '{print $2}')
            # Mevcut versiyonu al
            old_ver=$(flatpak info "$app_id" 2>/dev/null | grep "Version:" | awk '{print $2}' || echo "unknown")
            [[ -n "$app_id" ]] && add_package_info "$app_id" "$old_ver" "$new_ver" "flatpak"
        done <<< "$flatpak_updates"
    fi

    local flatpak_temp
    flatpak_temp=$(mktemp)

    if [[ "$VERBOSE_MODE" == "true" ]]; then
        flatpak update -y 2>&1 | tee -a "$LOG_FILE" | tee "$flatpak_temp" || print_warning "Flatpak hata verdi."
        flatpak uninstall --unused -y 2>&1 | tee -a "$LOG_FILE" || true
    else
        flatpak update -y 2>&1 | tee "$flatpak_temp" >> "$LOG_FILE" || print_warning "Flatpak hata verdi."
        flatpak uninstall --unused -y >> "$LOG_FILE" 2>&1 || true
    fi

    if grep -qi "Nothing to do" "$flatpak_temp" 2>/dev/null; then
        FLATPAK_COUNT=0
    else
        local flatpak_updated
        flatpak_updated=$(grep -cE "^[0-9]+\.\s" "$flatpak_temp" 2>/dev/null | tr -cd '0-9')
        flatpak_updated=${flatpak_updated:-0}
        if [[ "$flatpak_updated" -gt 0 ]]; then
            FLATPAK_COUNT=$flatpak_updated
        else
            FLATPAK_COUNT=${flatpak_upgradable:-0}
        fi
    fi

    rm -f "$flatpak_temp"

    print_info "Flatpak: $FLATPAK_COUNT uygulama güncellendi."
    add_pkg_manager_status "flatpak" "ran" "$FLATPAK_COUNT"
    return 0
}

# Snap Güncellemesi
update_snap() {
    if ! command -v snap &> /dev/null; then return 1; fi
    if [[ "$SKIP_SNAP" == "true" ]]; then return 1; fi
    if ! should_run_backend "snap"; then return 1; fi

    print_header "Snap: Güncelleme"

    local snap_updates snap_upgradable
    snap_updates=$(snap refresh --list 2>/dev/null | tail -n +2 || true)
    snap_upgradable=$(echo "$snap_updates" | grep -c . | tr -cd '0-9')
    snap_upgradable=${snap_upgradable:-0}
    SNAP_COUNT=${snap_upgradable:-0}

    # --json-full için paket detaylarını topla
    if [[ "$JSON_MODE" == "json-full" && -n "$snap_updates" ]]; then
        while IFS= read -r line; do
            local snap_name new_ver old_ver
            # Format: Name Version Rev Publisher Notes
            snap_name=$(echo "$line" | awk '{print $1}')
            new_ver=$(echo "$line" | awk '{print $2}')
            # Mevcut versiyonu al
            old_ver=$(snap info "$snap_name" 2>/dev/null | grep "installed:" | awk '{print $2}' || echo "unknown")
            [[ -n "$snap_name" ]] && add_package_info "$snap_name" "$old_ver" "$new_ver" "snap"
        done <<< "$snap_updates"
    fi

    if [[ "$VERBOSE_MODE" == "true" ]]; then
        snap refresh 2>&1 | tee -a "$LOG_FILE" || print_warning "Snap hata verdi."
    else
        snap refresh >> "$LOG_FILE" 2>&1 || print_warning "Snap hata verdi."
    fi

    print_info "Snap: $SNAP_COUNT paket güncellendi."
    add_pkg_manager_status "snap" "ran" "$SNAP_COUNT"
    return 0
}

# Firmware Güncellemesi
update_firmware() {
    if ! command -v fwupdmgr &> /dev/null; then return 1; fi
    if [[ "$SKIP_FWUPD" == "true" ]]; then return 1; fi
    if ! should_run_backend "fwupd"; then return 1; fi

    print_header "Firmware: Kontrol"

    local fwupd_output fwupd_exit_code=0
    fwupd_output=$(fwupdmgr get-updates 2>&1) || fwupd_exit_code=$?

    if [[ $fwupd_exit_code -eq 2 ]] || [[ "$fwupd_output" =~ "No updatable devices" ]]; then
        print_info "Firmware: Güncellenebilir cihaz bulunamadı."
        FWUPD_COUNT=0
        return 0
    fi

    if [[ $fwupd_exit_code -ne 0 ]]; then
        print_warning "Firmware kontrolü başarısız (exit code: $fwupd_exit_code)"
        FWUPD_COUNT=0
        return 1
    fi

    local fwupd_upgradable
    fwupd_upgradable=$(echo "$fwupd_output" | grep -c "New version" | tr -cd '0-9' || echo "0")
    fwupd_upgradable=${fwupd_upgradable:-0}
    FWUPD_COUNT=${fwupd_upgradable:-0}

    if [[ "${AUTO_MODE:-false}" == "true" ]]; then
        { fwupdmgr refresh --force || true; fwupdmgr update -y || true; } >> "$LOG_FILE" 2>&1
        if [[ "$QUIET_MODE" != "true" ]]; then
            printf '%sTamamlandı (Detaylar log dosyasında).%s\n' "${GREEN}" "${NC}"
        fi
    else
        if [[ "$VERBOSE_MODE" == "true" ]]; then
            fwupdmgr refresh --force 2>&1 | tee -a "$LOG_FILE" || true
            fwupdmgr update -y 2>&1 | tee -a "$LOG_FILE" || true
        else
            fwupdmgr refresh --force >> "$LOG_FILE" 2>&1 || true
            fwupdmgr update -y >> "$LOG_FILE" 2>&1 || true
        fi
    fi

    print_info "Firmware: $FWUPD_COUNT güncelleme."
    add_pkg_manager_status "fwupd" "ran" "$FWUPD_COUNT"
    return 0
}

# --- v3.8.0: DRY-RUN GÜNCELLEME LİSTELEME ---
perform_dry_run_check() {
    # JSON modunda sessiz çalış
    local json_quiet="false"
    [[ "$JSON_MODE" != "none" ]] && json_quiet="true"

    print_header "[DRY-RUN] Mevcut Güncellemeler Kontrol Ediliyor"

    # APT
    if command -v apt-get &> /dev/null && [[ "$SKIP_PKG_MANAGER" != "true" ]] && should_run_backend "apt"; then
        print_dry_run "APT: Güncellenebilir paketler listeleniyor..."
        [[ "$json_quiet" == "false" ]] && printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
        apt-get update -qq >> "$LOG_FILE" 2>&1 || true
        local apt_list
        apt_list=$(apt list --upgradable 2>/dev/null | grep -v "Listing..." || true)
        if [[ -n "$apt_list" ]]; then
            [[ "$json_quiet" == "false" ]] && echo "$apt_list"
            APT_COUNT=$(echo "$apt_list" | wc -l | tr -cd '0-9')
        else
            [[ "$json_quiet" == "false" ]] && printf '%s  Tüm paketler güncel.%s\n' "${GREEN}" "${NC}"
            APT_COUNT=0
        fi
        [[ "$json_quiet" == "false" ]] && echo ""
        add_pkg_manager_status "apt" "checked" "$APT_COUNT"
    fi
    
    # DNF
    if command -v dnf &> /dev/null && [[ "$SKIP_PKG_MANAGER" != "true" ]] && should_run_backend "dnf"; then
        print_dry_run "DNF: Güncellenebilir paketler listeleniyor..."
        [[ "$json_quiet" == "false" ]] && printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
        local dnf_list
        dnf_list=$(dnf check-update 2>/dev/null | grep -v "^$" | grep -v "Last metadata" || true)
        if [[ -n "$dnf_list" ]]; then
            [[ "$json_quiet" == "false" ]] && echo "$dnf_list"
            DNF_COUNT=$(echo "$dnf_list" | wc -l | tr -cd '0-9')
        else
            [[ "$json_quiet" == "false" ]] && printf '%s  Tüm paketler güncel.%s\n' "${GREEN}" "${NC}"
            DNF_COUNT=0
        fi
        [[ "$json_quiet" == "false" ]] && echo ""
        add_pkg_manager_status "dnf" "checked" "$DNF_COUNT"
    fi

    # Pacman (v5.0 BigFour)
    if command -v pacman &> /dev/null && [[ "$SKIP_PKG_MANAGER" != "true" ]] && should_run_backend "pacman"; then
        print_dry_run "Pacman: Güncellenebilir paketler listeleniyor..."
        [[ "$json_quiet" == "false" ]] && printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
        pacman -Sy >> "$LOG_FILE" 2>&1 || true
        local pacman_list
        pacman_list=$(pacman -Qu 2>/dev/null || true)
        if [[ -n "$pacman_list" ]]; then
            [[ "$json_quiet" == "false" ]] && echo "$pacman_list"
            PACMAN_COUNT=$(echo "$pacman_list" | wc -l | tr -cd '0-9')
        else
            [[ "$json_quiet" == "false" ]] && printf '%s  Tüm paketler güncel.%s\n' "${GREEN}" "${NC}"
            PACMAN_COUNT=0
        fi
        [[ "$json_quiet" == "false" ]] && echo ""
        add_pkg_manager_status "pacman" "checked" "$PACMAN_COUNT"
    fi

    # Zypper (v5.0 BigFour)
    if command -v zypper &> /dev/null && [[ "$SKIP_PKG_MANAGER" != "true" ]] && should_run_backend "zypper"; then
        print_dry_run "Zypper: Güncellenebilir paketler listeleniyor..."
        [[ "$json_quiet" == "false" ]] && printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
        zypper refresh >> "$LOG_FILE" 2>&1 || true
        local zypper_list
        zypper_list=$(zypper -q lu 2>/dev/null | grep "^v" || true)
        if [[ -n "$zypper_list" ]]; then
            [[ "$json_quiet" == "false" ]] && echo "$zypper_list"
            ZYPPER_COUNT=$(echo "$zypper_list" | wc -l | tr -cd '0-9')
        else
            [[ "$json_quiet" == "false" ]] && printf '%s  Tüm paketler güncel.%s\n' "${GREEN}" "${NC}"
            ZYPPER_COUNT=0
        fi
        [[ "$json_quiet" == "false" ]] && echo ""
        add_pkg_manager_status "zypper" "checked" "$ZYPPER_COUNT"
    fi

    # APK (v5.1 BigFive - Alpine Linux)
    if command -v apk &> /dev/null && [[ "$SKIP_PKG_MANAGER" != "true" ]] && should_run_backend "apk"; then
        print_dry_run "APK: Güncellenebilir paketler listeleniyor..."
        [[ "$json_quiet" == "false" ]] && printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
        apk update >> "$LOG_FILE" 2>&1 || true
        local apk_list
        apk_list=$(apk version -l '<' 2>/dev/null || true)
        if [[ -n "$apk_list" ]]; then
            [[ "$json_quiet" == "false" ]] && echo "$apk_list"
            APK_COUNT=$(echo "$apk_list" | wc -l | tr -cd '0-9')
        else
            [[ "$json_quiet" == "false" ]] && printf '%s  Tüm paketler güncel.%s\n' "${GREEN}" "${NC}"
            APK_COUNT=0
        fi
        [[ "$json_quiet" == "false" ]] && echo ""
        add_pkg_manager_status "apk" "checked" "$APK_COUNT"
    fi

    # Flatpak
    if command -v flatpak &> /dev/null && [[ "$SKIP_FLATPAK" != "true" ]] && should_run_backend "flatpak"; then
        print_dry_run "Flatpak: Güncellenebilir uygulamalar listeleniyor..."
        [[ "$json_quiet" == "false" ]] && printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
        local flatpak_list
        flatpak_list=$(flatpak remote-ls --updates 2>/dev/null || true)
        if [[ -n "$flatpak_list" ]]; then
            [[ "$json_quiet" == "false" ]] && echo "$flatpak_list"
            FLATPAK_COUNT=$(echo "$flatpak_list" | wc -l | tr -cd '0-9')
        else
            [[ "$json_quiet" == "false" ]] && printf '%s  Tüm uygulamalar güncel.%s\n' "${GREEN}" "${NC}"
            FLATPAK_COUNT=0
        fi
        [[ "$json_quiet" == "false" ]] && echo ""
        add_pkg_manager_status "flatpak" "checked" "$FLATPAK_COUNT"
    fi

    # Snap
    if command -v snap &> /dev/null && [[ "$SKIP_SNAP" != "true" ]] && should_run_backend "snap"; then
        print_dry_run "Snap: Güncellenebilir paketler listeleniyor..."
        [[ "$json_quiet" == "false" ]] && printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
        local snap_list
        snap_list=$(snap refresh --list 2>/dev/null | tail -n +2 || true)
        if [[ -n "$snap_list" ]]; then
            [[ "$json_quiet" == "false" ]] && echo "$snap_list"
            SNAP_COUNT=$(echo "$snap_list" | wc -l | tr -cd '0-9')
        else
            [[ "$json_quiet" == "false" ]] && printf '%s  Tüm paketler güncel.%s\n' "${GREEN}" "${NC}"
            SNAP_COUNT=0
        fi
        [[ "$json_quiet" == "false" ]] && echo ""
        add_pkg_manager_status "snap" "checked" "$SNAP_COUNT"
    fi

    # Firmware - v3.8.1 FIX: "No updatable devices" durumunda exit 0
    if command -v fwupdmgr &> /dev/null && [[ "$SKIP_FWUPD" != "true" ]] && should_run_backend "fwupd"; then
        print_dry_run "Firmware: Mevcut güncellemeler kontrol ediliyor..."
        [[ "$json_quiet" == "false" ]] && printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
        fwupdmgr refresh --force >> "$LOG_FILE" 2>&1 || true
        local fwupd_list fwupd_exit_code
        fwupd_list=$(fwupdmgr get-updates 2>&1) || fwupd_exit_code=$?
        # fwupdmgr returns exit code 2 for "No updatable devices" - this is not an error
        if [[ -n "$fwupd_list" && ! "$fwupd_list" =~ "No upgrades" && ! "$fwupd_list" =~ "No updatable devices" ]]; then
            [[ "$json_quiet" == "false" ]] && echo "$fwupd_list"
            FWUPD_COUNT=$(echo "$fwupd_list" | grep -c "New version" | tr -cd '0-9' || echo "0")
        else
            [[ "$json_quiet" == "false" ]] && printf '%s  Firmware güncel.%s\n' "${GREEN}" "${NC}"
            FWUPD_COUNT=0
        fi
        [[ "$json_quiet" == "false" ]] && echo ""
        add_pkg_manager_status "fwupd" "checked" "$FWUPD_COUNT"
    fi
}

perform_updates() {
    # v3.8.0: Dry-run modunda sadece listele
    if [[ "$DRY_RUN" == "true" ]]; then
        perform_dry_run_check
        return
    fi

    # v5.1: Modüler güncelleme - BigFive Edition
    # Sistem paket yöneticisi (sadece biri çalışır: APT, DNF, Pacman, Zypper veya APK)
    update_apt || update_dnf || update_pacman || update_zypper || update_apk || true

    # Diğer backend'ler
    update_flatpak || true
    update_snap || true
    update_firmware || true
}

# --- UNINSTALL FONKSİYONU ---
do_uninstall() {
    printf '%s>>> ARCB Wider Updater Kaldırma%s\n' "${BLUE}${BOLD}" "${NC}"
    echo "--------------------------------------------------"

    local removed_items=()
    local failed_items=()

    # Binary
    if [[ -f "/usr/local/bin/guncel" ]]; then
        if rm -f "/usr/local/bin/guncel"; then
            removed_items+=("Binary: /usr/local/bin/guncel")
        else
            failed_items+=("Binary: /usr/local/bin/guncel")
        fi
    fi

    # Symlink: updater
    if [[ -L "/usr/local/bin/updater" ]]; then
        rm -f "/usr/local/bin/updater" && removed_items+=("Symlink: /usr/local/bin/updater")
    fi

    # Symlink: bigfive
    if [[ -L "/usr/local/bin/bigfive" ]]; then
        rm -f "/usr/local/bin/bigfive" && removed_items+=("Symlink: /usr/local/bin/bigfive")
    fi

    # Backup dosyası
    if [[ -f "/usr/local/bin/guncel.bak" ]]; then
        rm -f "/usr/local/bin/guncel.bak" && removed_items+=("Backup: /usr/local/bin/guncel.bak")
    fi

    # Arşiv yedekleri
    local backup_count=0
    for f in /usr/local/bin/guncel.bak_*; do
        [[ -f "$f" ]] && rm -f "$f" && ((backup_count++))
    done
    [[ $backup_count -gt 0 ]] && removed_items+=("Arşiv yedekleri: $backup_count dosya")

    # Config dosyası
    if [[ -f "$CONFIG_FILE" ]]; then
        if [[ "${1:-}" == "--purge" ]]; then
            rm -f "$CONFIG_FILE" && removed_items+=("Config: $CONFIG_FILE")
        else
            printf '%s[i] Config dosyası korundu: %s%s\n' "${BLUE}" "$CONFIG_FILE" "${NC}"
            printf '%s    Silmek için: guncel --uninstall --purge%s\n' "${BLUE}" "${NC}"
        fi
    fi

    # Logrotate config
    if [[ -f "/etc/logrotate.d/arcb-wider-updater" ]]; then
        rm -f "/etc/logrotate.d/arcb-wider-updater" && removed_items+=("Logrotate: /etc/logrotate.d/arcb-wider-updater")
    fi

    # Log dizini
    if [[ -d "$LOG_DIR" ]]; then
        if [[ "${1:-}" == "--purge" ]]; then
            rm -rf "$LOG_DIR" && removed_items+=("Log dizini: $LOG_DIR")
        else
            printf '%s[i] Log dizini korundu: %s%s\n' "${BLUE}" "$LOG_DIR" "${NC}"
            printf '%s    Silmek için: guncel --uninstall --purge%s\n' "${BLUE}" "${NC}"
        fi
    fi

    # Lock dosyası
    rm -f "/var/lock/arcb-wider-updater.lock" 2>/dev/null

    echo ""
    if [[ ${#removed_items[@]} -gt 0 ]]; then
        printf '%s✅ Kaldırılan öğeler:%s\n' "${GREEN}" "${NC}"
        for item in "${removed_items[@]}"; do
            printf '%s   - %s%s\n' "${GREEN}" "$item" "${NC}"
        done
    fi

    if [[ ${#failed_items[@]} -gt 0 ]]; then
        printf '%s❌ Kaldırılamayan öğeler:%s\n' "${RED}" "${NC}"
        for item in "${failed_items[@]}"; do
            printf '%s   - %s%s\n' "${RED}" "$item" "${NC}"
        done
        exit 1
    fi

    echo ""
    printf '%s✅ ARCB Wider Updater başarıyla kaldırıldı.%s\n' "${GREEN}${BOLD}" "${NC}"
    exit 0
}

show_help() {
    printf '%sARCB Wider Updater v%s (%s Edition - %s)%s\n' "${BOLD}" "$VERSION" "$EDITION" "$CODENAME" "${NC}"
    echo "--------------------------------------------------"
    echo "Kullanım: guncel | updater | bigfive [SEÇENEK]"
    echo ""
    echo "Seçenekler:"
    echo "  --auto              Otomatik mod (Onay sormadan günceller)"
    echo "  --verbose           Detaylı çıktı modu (Tüm komut çıktılarını gösterir)"
    echo "  --quiet             Sessiz mod (Sadece hata ve özet gösterir)"
    echo "  --dry-run           Kuru çalıştırma (Ne yapılacağını göster, yapma)"
    echo "  --json              JSON çıktı (monitoring sistemleri için)"
    echo "  --json-full         Detaylı JSON çıktı (SIEM/audit için)"
    echo "  --skip <backend>    Belirtilen backend'leri atla (virgülle ayır)"
    echo "                      Değerler: snapshot, flatpak, snap, fwupd, system"
    echo "                      (system = apt, dnf, pacman, zypper, apk)"
    echo "  --only <backend>    Sadece belirtilen backend'leri çalıştır (virgülle ayır)"
    echo "                      Değerler: system, flatpak, snap, fwupd, apt, dnf, pacman, zypper, apk"
    echo "  --uninstall         ARCB Wider Updater'ı kaldır"
    echo "  --uninstall --purge Config ve logları da sil"
    echo "  --help              Bu yardım mesajını gösterir"
    echo ""
    echo "Örnekler:"
    echo "  guncel                        -> İnteraktif (Önerilen)"
    echo "  guncel --auto                 -> Cron / Zamanlanmış görevler"
    echo "  guncel --verbose              -> Detaylı çıktı ile güncelleme"
    echo "  guncel --quiet                -> Sessiz güncelleme (sadece özet)"
    echo "  guncel --dry-run              -> Güncellemeleri listele (uygulamadan)"
    echo "  guncel --json                 -> Monitoring için JSON çıktı (Zabbix/Nagios)"
    echo "  guncel --json-full            -> SIEM için detaylı JSON (Wazuh/Splunk)"
    echo "  guncel --skip flatpak,snap    -> Flatpak ve Snap atla"
    echo "  guncel --only system          -> Sadece sistem paketleri (APT/DNF/Pacman/Zypper/APK)"
    echo "  guncel --only flatpak,fwupd   -> Sadece Flatpak ve Firmware"
    echo "  guncel --only pacman          -> Sadece Pacman (Arch Linux)"
    echo "  guncel --only apk             -> Sadece APK (Alpine Linux)"
    echo "  guncel --uninstall            -> Aracı kaldır (config/log korunur)"
    echo "  guncel --uninstall --purge    -> Aracı tamamen kaldır"
    echo ""
    echo "Config Dosyası: $CONFIG_FILE"
    echo "  Varsayılan ayarları config dosyasında tanımlayabilirsiniz."
    echo "  Örnek: /etc/arcb-wider-updater.conf.example"
    exit 0
}

# --- ARGUMENT PARSING ---
while [[ $# -gt 0 ]]; do
    case $1 in
        --auto) AUTO_MODE="true"; shift ;;
        --verbose) VERBOSE_MODE="true"; shift ;;
        --quiet) QUIET_MODE="true"; shift ;;
        --dry-run) DRY_RUN="true"; shift ;;
        --json) JSON_MODE="json"; QUIET_MODE="true"; shift ;;
        --json-full) JSON_MODE="json-full"; QUIET_MODE="true"; shift ;;
        --skip)
            if [[ -n "${2:-}" && ! "$2" =~ ^-- ]]; then
                IFS=',' read -ra SKIP_ITEMS <<< "$2"
                for item in "${SKIP_ITEMS[@]}"; do
                    case "$item" in
                        snapshot) SKIP_SNAPSHOT=true ;;
                        flatpak) SKIP_FLATPAK=true ;;
                        snap) SKIP_SNAP=true ;;
                        fwupd) SKIP_FWUPD=true ;;
                        dnf|apt|system) SKIP_PKG_MANAGER=true ;;  # Paket yöneticisini (APT/DNF) atla
                        *) printf '%sUyarı: Bilinmeyen skip değeri: %s%s\n' "${YELLOW}" "$item" "${NC}" ;;
                    esac
                done
                shift 2
            else
                printf '%sHATA: --skip için değer gerekli (örn: --skip flatpak,snap)%s\n' "${RED}" "${NC}"
                exit 1
            fi
            ;;
        --only)
            if [[ -n "${2:-}" && ! "$2" =~ ^-- ]]; then
                ONLY_MODE="$2"
                shift 2
            else
                printf '%sHATA: --only için değer gerekli (örn: --only system)%s\n' "${RED}" "${NC}"
                exit 1
            fi
            ;;
        --uninstall)
            shift
            # --purge kontrolü
            if [[ "${1:-}" == "--purge" ]]; then
                do_uninstall "--purge"
            else
                do_uninstall
            fi
            ;;
        --help) show_help ;;
        *) printf '%sUyarı: Bilinmeyen argüman: %s%s\n' "${YELLOW}" "$1" "${NC}"; shift ;;
    esac
done

# Verbose ve quiet aynı anda kullanılamaz
if [[ "$VERBOSE_MODE" == "true" && "$QUIET_MODE" == "true" ]]; then
    printf '%sHATA: --verbose ve --quiet aynı anda kullanılamaz.%s\n' "${RED}" "${NC}"
    exit 1
fi

check_root

# --- FLOCK: Eşzamanlı çalışma kilidi ---
LOCK_FILE="/var/lock/arcb-wider-updater.lock"
# Bazı container'larda /var/lock veya /run/lock yoksa oluştur
# Fedora/RHEL'de /var/lock -> /run/lock symlink'i var
if [[ -L "/var/lock" ]]; then
    # Symlink varsa hedef dizini oluştur
    mkdir -p "/run/lock" 2>/dev/null || true
elif [[ ! -d "/var/lock" ]]; then
    mkdir -p "/var/lock" 2>/dev/null || true
fi
exec 9>"$LOCK_FILE"
if ! flock -n 9; then
    print_error "Başka bir güncelleme işlemi zaten çalışıyor."
    exit 1
fi
setup_logging

if ! check_connectivity; then
    print_error "İnternet bağlantısı kurulamadı. İşlem iptal."
    exit 1
fi

check_self_update

# v5.3.0: JSON output için başlangıç zamanını kaydet
START_TIME=$(date +%s)

if [[ "$AUTO_MODE" != "true" && "$QUIET_MODE" != "true" ]]; then clear 2>/dev/null || true; fi

# Başlangıç özeti
print_system_header

if [[ "$QUIET_MODE" != "true" ]]; then
    printf '%s   Log: %s%s\n' "${BLUE}" "$LOG_FILE" "${NC}"
    printf '%s   Mod: %s%s\n' "${BLUE}" "$( [[ "$AUTO_MODE" == "true" ]] && echo "Otomatik 🤖" || echo "İnteraktif 👤" )" "${NC}"
    [[ "$VERBOSE_MODE" == "true" ]] && printf '%s   Verbose: Aktif%s\n' "${BLUE}" "${NC}"
    [[ "$DRY_RUN" == "true" ]] && printf '%s   Dry-Run: Aktif (Değişiklik yapılmayacak)%s\n' "${YELLOW}" "${NC}"
    [[ -n "$ONLY_MODE" ]] && printf '%s   Only: %s%s\n' "${BLUE}" "$ONLY_MODE" "${NC}"
    echo ""
fi

create_snapshot
perform_updates

# Bitiş özeti
print_final_summary

# v5.3.0: JSON output
if [[ "$JSON_MODE" != "none" ]]; then
    output_json 0
fi
