#!/usr/bin/env bash
set -euo pipefail

# ==============================================================================
# ARCB Wider Updater - v2.97
# Tembel ama takıntılı adminin en yakın dostu
# ==============================================================================
VERSION="2.97"
APPNAME="ARCB Wider Updater"
TZ="${TZ:-Europe/Istanbul}"

# Defaults (ENV can override)
SHOW_OUTPUT="${SHOW_OUTPUT:-0}"   # 0: only log, 1: show output on screen too
NO_GUI="${NO_GUI:-0}"             # 1: never prompt zenity/interactive log view

usage() {
  cat <<'EOF'
Usage: ./guncel [--show-output] [--no-gui] [--help]

  --show-output   Also show command outputs in terminal (still logs to file)
  --no-gui        Disable zenity prompts and log viewer
  --help          Show this help

Environment overrides:
  SHOW_OUTPUT=1   Same as --show-output
  NO_GUI=1        Same as --no-gui
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --show-output) SHOW_OUTPUT=1; shift ;;
    --no-gui) NO_GUI=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) echo "ERR: Unknown argument: $1" >&2; usage; exit 2 ;;
  esac
done

# ==============================================================================
# Paths
# ==============================================================================
LOGDIR="${HOME}/Logs"
mkdir -p "$LOGDIR"
NOW="$(date '+%Y-%m-%d_%H-%M-%S')"
LOGFILE="${LOGDIR}/arcb_wider_updater_${NOW}.log"

# ==============================================================================
# Helpers
# ==============================================================================
ts() { date '+[%Y-%m-%d %H:%M:%S %z]'; }

log() {
  printf '%s %s\n' "$(ts)" "$*" | tee -a "$LOGFILE"
}

hr() {
  printf '%*s\n' 94 '' | tr ' ' '-' | tee -a "$LOGFILE"
}

sec() {
  hr
  log "▶ $*"
  hr
}

has() { command -v "$1" >/dev/null 2>&1; }

LC_C() { LC_ALL=C "$@"; }

# ==============================================================================
# Trap manager (NO login shell! avoids "Agent pid ..." side effects)
# ==============================================================================
TRAP_CMDS=()
add_trap() { TRAP_CMDS+=("$*"); }

run_traps() {
  local i cmd
  for (( i=${#TRAP_CMDS[@]}-1; i>=0; i-- )); do
    cmd="${TRAP_CMDS[i]}"
    # execute in current shell; no .bashrc/.profile noise
    eval "$cmd" || true
  done
}
trap run_traps EXIT

# ==============================================================================
# Concurrency lock
# ==============================================================================
LOCKFILE="/tmp/arcb_wider_updater.lock"

lock_init() {
  if [[ -e "$LOCKFILE" ]]; then
    local oldpid=""
    oldpid="$(cat "$LOCKFILE" 2>/dev/null || true)"
    if [[ -n "$oldpid" ]] && kill -0 "$oldpid" 2>/dev/null; then
      echo "ERR: ${APPNAME} zaten çalışıyor! (PID: $oldpid)" >&2
      exit 1
    fi
  fi
  echo "$$" >"$LOCKFILE"
  add_trap "rm -f \"$LOCKFILE\" 2>/dev/null || true"
}

# ==============================================================================
# Runner: soft run (never stops script), logs always, optional screen output
# ==============================================================================
soft_run() {
  local rc=0
  log "+ $*"

  if [[ "$SHOW_OUTPUT" == "1" ]]; then
    "$@" 2>&1 | tee -a "$LOGFILE"
    rc=${PIPESTATUS[0]}
  else
    "$@" >>"$LOGFILE" 2>&1 || rc=$?
  fi

  if (( rc != 0 )); then
    log "⏭ Komut hata verdi ama devam ediyorum (rc=${rc}): $*"
  fi
  return 0
}

soft_run_allow_rcs() {
  local allow="$1"; shift
  local rc=0
  log "+ $*"

  if [[ "$SHOW_OUTPUT" == "1" ]]; then
    "$@" 2>&1 | tee -a "$LOGFILE"
    rc=${PIPESTATUS[0]}
  else
    "$@" >>"$LOGFILE" 2>&1 || rc=$?
  fi

  local ok
  for ok in $allow; do
    if [[ "$rc" == "$ok" ]]; then
      if (( rc != 0 )); then
        log "ℹ Komut rc=${rc} döndü ama izinli kabul edildi: $*"
      fi
      return 0
    fi
  done

  log "⏭ Komut rc=${rc} (izinli değil) ama devam ediyorum: $*"
  return 0
}

# ==============================================================================
# System info helpers
# ==============================================================================
os_pretty() {
  local v=""
  v="$(grep -E '^PRETTY_NAME=' /etc/os-release 2>/dev/null | head -n1 | cut -d= -f2- | tr -d '"')" || true
  echo "${v:-Unknown}"
}

disk_line_root() {
  LC_C df -Ph / 2>/dev/null | awk 'NR==2{print $2" total, "$3" used, "$4" free ("$5" used)"}' || echo "Unknown"
}

uptime_line() {
  uptime -p 2>/dev/null | sed 's/^up //' || echo "Unknown"
}

disk_all_partitions_warn() {
  local out=""
  out="$(LC_C df -h -x tmpfs -x devtmpfs 2>/dev/null | awk 'NR>1{
    gsub(/%/,"",$5);
    if($5+0>85) print "⚠ " $6 " partition %" $5 " dolu!";
  }')" || true
  if [[ -n "$out" ]]; then
    log "$out"
  fi
}

# ==============================================================================
# Interactive / GUI
# ==============================================================================
gui_question() {
  local prompt="$1"
  if [[ "$NO_GUI" == "1" ]]; then
    return 1
  fi
  if has zenity; then
    zenity --question --width=520 --text="$prompt" >/dev/null 2>&1
    return $?
  fi
  printf '%s [y/N]: ' "$prompt" >&2
  local ans=""
  IFS= read -r ans || true
  ans="${ans,,}"
  [[ "$ans" == "y" || "$ans" == "yes" ]]
}

gui_log() {
  if [[ "$NO_GUI" == "1" ]]; then
    return 0
  fi
  sync || true; sleep 0.2
  if has zenity; then
    zenity --text-info --width=900 --height=600 --title="${APPNAME} - Log" --filename="$LOGFILE" >/dev/null 2>&1 || true
  elif has less; then
    less "$LOGFILE" || true
  else
    tail -n 200 "$LOGFILE" || true
  fi
}

prompt_yes_no_timeout() {
  local prompt="$1"
  local timeout_s="${2:-10}"

  printf '%s [y/N] (auto No in %ss): ' "$prompt" "$timeout_s" | tee -a "$LOGFILE"
  local ans=""

  if IFS= read -r -t "$timeout_s" ans; then
    echo "$ans" | tee -a "$LOGFILE" >/dev/null
  else
    echo | tee -a "$LOGFILE" >/dev/null
    return 1
  fi

  ans="${ans,,}"
  [[ "$ans" == "y" || "$ans" == "yes" ]]
}

# ==============================================================================
# Sudo keepalive
# ==============================================================================
SUDO_KEEPALIVE_PID=""

start_sudo_keepalive() {
  if ! has sudo; then return 0; fi
  if [[ $EUID -eq 0 ]]; then return 0; fi

  sec "Sudo önbelleme"
  if ! sudo -v; then
    log "ERR: Sudo parolası girilmedi. Çıkılıyor."
    exit 1
  fi

  (
    while true; do
      sudo -n true >/dev/null 2>&1 || exit 0
      sleep 200
    done
  ) &
  SUDO_KEEPALIVE_PID="$!"
  add_trap "kill \"$SUDO_KEEPALIVE_PID\" 2>/dev/null || true"
}

# ==============================================================================
# Health checks
# ==============================================================================
svc_active() {
  local svc="$1"
  if has systemctl; then
    systemctl is-active --quiet "$svc" 2>/dev/null
    return $?
  fi
  return 1
}

snap_health() {
  if ! has snap; then return 1; fi
  if [[ -S /run/snapd.socket ]]; then return 0; fi
  if svc_active snapd; then return 0; fi
  return 1
}

# ==============================================================================
# Update backends
# ==============================================================================
dnf_update_and_cleanup() {
  if ! has dnf; then return 0; fi
  sec "DNF: upgrade (refresh)"
  soft_run sudo dnf -y upgrade --refresh
  sec "DNF: cleanup"
  soft_run sudo dnf -y autoremove
  soft_run sudo dnf -y clean all
}

apt_update_and_cleanup() {
  if ! has apt-get; then return 0; fi
  sec "APT: update & upgrade"
  soft_run sudo apt-get update
  soft_run sudo apt-get -y full-upgrade
  sec "APT: cleanup"
  soft_run sudo apt-get -y autoremove --purge
  soft_run sudo apt-get -y autoclean
}

flatpak_update_and_cleanup() {
  if ! has flatpak; then return 0; fi
  sec "Flatpak: update"
  soft_run flatpak -y update
  sec "Flatpak: unused remove"
  soft_run flatpak -y uninstall --unused
}

snap_refresh() {
  if ! has snap; then return 0; fi
  sec "Snap"
  if snap_health; then
    soft_run sudo snap refresh
  else
    log "⏭ snap atlandı (snapd sağlıklı değil)"
  fi
}

fwupd_refresh_and_updates() {
  if ! has fwupdmgr; then return 0; fi
  sec "FWUPD"
  soft_run sudo fwupdmgr refresh --force
  soft_run_allow_rcs "0 2" sudo fwupdmgr get-updates
}

# ==============================================================================
# Optional maintenance
# ==============================================================================
journal_vacuum_optional() {
  if ! has journalctl; then return 0; fi
  sec "Journal temizliği - opsiyonel"
  local j_cmd="journalctl --vacuum-size=100M --vacuum-time=7d"
  log "Komut: $j_cmd"
  log "Not: Eski loglar silinir (debug geçmişi kısalır)."

  if prompt_yes_no_timeout "Journal loglarını küçülteyim mi?" 10; then
    # shellcheck disable=SC2086
    soft_run sudo $j_cmd
  else
    log "⏭ Journal temizliği atlandı (timeout veya No)"
  fi
}

failed_services() {
  if ! has systemctl; then return 0; fi
  sec "Başarısız servisler"
  if systemctl --failed --no-legend 2>/dev/null | grep -q .; then
    log "⚠ Başarısız servisler:"
    systemctl --failed --no-legend 2>/dev/null | tee -a "$LOGFILE" || true
  else
    log "✔ Başarısız servis yok"
  fi
}

boot_perf() {
  if ! has systemd-analyze; then return 0; fi
  sec "Sistem performansı (boot zamanı)"
  soft_run systemd-analyze
  log "Top 10 (systemd-analyze blame):"
  LC_C systemd-analyze blame 2>/dev/null | head -n 10 | tee -a "$LOGFILE" || true
}

reboot_hint() {
  local needs_reboot=0

  if has needs-restarting && has sudo; then
    if ! sudo needs-restarting -r >/dev/null 2>&1; then
      needs_reboot=1
    fi
  fi

  if [[ -f /var/run/reboot-required ]]; then
    needs_reboot=1
  fi

  if (( needs_reboot == 1 )); then
    log "⚠ REBOOT GEREKİYOR (Kernel/Kritik güncelleme)"
  fi
}

# ==============================================================================
# MAIN
# ==============================================================================
lock_init

KERNEL_BEFORE="$(uname -r 2>/dev/null || echo Unknown)"
HOSTN="$(hostname 2>/dev/null || echo Unknown)"
USERN="${USER:-$(whoami 2>/dev/null || echo Unknown)}"
UPTIME_BEFORE="$(uptime_line)"
DISK_BEFORE="$(disk_line_root)"

hr
log "${APPNAME} v${VERSION} - Tembel ama takıntılı adminin en yakın dostu"
hr
log "HOST   : ${HOSTN}"
log "USER   : ${USERN}"
log "KERNEL : ${KERNEL_BEFORE}"
log "UPTIME : ${UPTIME_BEFORE}"
log "DISK   : ${DISK_BEFORE}"
log "LOG    : ${LOGFILE}"
hr

start_sudo_keepalive

sec "Sistem özeti"
log "OS     : $(os_pretty)"
log "CPU    : $(LC_C lscpu 2>/dev/null | awk -F: '/Model name/ {gsub(/^[ \t]+/,"",$2); print $2; exit}' || echo Unknown)"
log "RAM    : $(LC_C free -h 2>/dev/null | awk '/Mem:/ {print $2" total, "$3" used, "$7" available"}' || echo Unknown)"
log "ROOTFS : ${DISK_BEFORE}"
log "DISK   :"
LC_C df -h 2>/dev/null | tee -a "$LOGFILE" || true

sec "Araç durumu"
for tool in apt-get dnf flatpak fwupdmgr zenity systemctl systemd-analyze journalctl snap; do
  if has "$tool"; then
    log "✔ $tool"
  else
    log "✖ $tool"
  fi
done

if has snap; then
  if snap_health; then
    log "✔ snap (snapd aktif)"
  else
    log "✖ snap (snapd aktif değil)"
  fi
fi

dnf_update_and_cleanup
apt_update_and_cleanup
flatpak_update_and_cleanup
snap_refresh
fwupd_refresh_and_updates

journal_vacuum_optional
failed_services
boot_perf
disk_all_partitions_warn

KERNEL_AFTER="$(uname -r 2>/dev/null || echo Unknown)"
DISK_AFTER="$(disk_line_root)"

sec "Özet"
log "✔ Güncelleme tamamlandı."
log "▶ Kernel (önce): ${KERNEL_BEFORE}"
log "▶ Kernel (şimdi): ${KERNEL_AFTER}"
log "▶ Disk (önce)  : ${DISK_BEFORE}"
log "▶ Disk (şimdi) : ${DISK_AFTER}"
log "▶ Log          : ${LOGFILE}"

reboot_hint
hr

if gui_question "Log dosyasını görüntüleyeyim mi?\n\n${LOGFILE}"; then
  gui_log
fi
