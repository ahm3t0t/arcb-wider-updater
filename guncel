#!/usr/bin/env bash
#
# ARCB Wider Updater v3.8.2 - Documented
# GitHub: https://github.com/ahm3t0t/arcb-wider-updater
#

# --- AYARLAR ---
VERSION="3.9.0"
CODENAME="Tested"
LOG_DIR="/var/log/arcb-updater"
LOG_FILE="$LOG_DIR/update_$(date +%Y%m%d_%H%M%S).log"
GITHUB_RAW_URL="https://raw.githubusercontent.com/ahm3t0t/arcb-wider-updater/main/guncel"
GITHUB_SHA256_URL="https://github.com/ahm3t0t/arcb-wider-updater/releases/latest/download/SHA256SUMS"
CONFIG_FILE="/etc/arcb-wider-updater.conf"

# STRICT MODE
set -Eeuo pipefail

# GÃœVENLÄ°K: Log ve temp dosyalar sadece root okusun
umask 0077

# Renkler (ANSI-C quoting ile)
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[0;33m'
BLUE=$'\033[0;34m'
BOLD=$'\033[1m'
NC=$'\033[0m'

# --- YENÄ°: MODLAR VE SAYAÃ‡LAR ---
VERBOSE_MODE=false
QUIET_MODE=false
AUTO_MODE=false
DRY_RUN=false

# --- YENÄ° v3.6.0: SKIP/ONLY BAYRAKLARI ---
SKIP_SNAPSHOT=false
SKIP_FLATPAK=false
SKIP_SNAP=false
SKIP_FWUPD=false
SKIP_DNF=false
ONLY_MODE=""

# GÃ¼ncelleme sayaÃ§larÄ± - FIX: Ensure they're always numeric
APT_COUNT=0
DNF_COUNT=0
FLATPAK_COUNT=0
SNAP_COUNT=0
FWUPD_COUNT=0
SNAPSHOT_NAME=""

# v3.6.1 FIX: Orijinal argÃ¼manlarÄ± sakla (check_root iÃ§in)
ORIGINAL_ARGS=("$@")

# --- YENÄ° v3.6.0: CONFIG DOSYASI YÃœKLEME ---
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
        # Config'den gelen deÄŸerleri uygula
        VERBOSE_MODE="${CONFIG_VERBOSE:-$VERBOSE_MODE}"
        QUIET_MODE="${CONFIG_QUIET:-$QUIET_MODE}"
        AUTO_MODE="${CONFIG_AUTO:-$AUTO_MODE}"
        SKIP_SNAPSHOT="${CONFIG_SKIP_SNAPSHOT:-$SKIP_SNAPSHOT}"
        SKIP_FLATPAK="${CONFIG_SKIP_FLATPAK:-$SKIP_FLATPAK}"
        SKIP_SNAP="${CONFIG_SKIP_SNAP:-$SKIP_SNAP}"
        SKIP_FWUPD="${CONFIG_SKIP_FWUPD:-$SKIP_FWUPD}"
        SKIP_DNF="${CONFIG_SKIP_DNF:-$SKIP_DNF}"
        # Renk ayarlarÄ± (opsiyonel)
        RED="${CONFIG_COLOR_RED:-$RED}"
        GREEN="${CONFIG_COLOR_GREEN:-$GREEN}"
        YELLOW="${CONFIG_COLOR_YELLOW:-$YELLOW}"
        BLUE="${CONFIG_COLOR_BLUE:-$BLUE}"
    fi
}

# Config'i yÃ¼kle (argÃ¼manlardan Ã¶nce, argÃ¼manlar override eder)
load_config

# --- TRAP & LOGGING ---
finish_logging() {
    local ec=$?
    if [ -f "$LOG_FILE" ]; then
        echo "[$(date '+%F %T')] INFO: Finished with exit_code=$ec" >> "$LOG_FILE"
    fi
}
trap finish_logging EXIT

print_header() {
    if [[ "$QUIET_MODE" == "true" ]]; then return; fi
    printf '\n%s>>> %s %s\n' "${BLUE}${BOLD}" "$1" "${NC}"
    printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
    echo "[$(date '+%F %T')] >>> $1" >> "$LOG_FILE"
}

print_error() {
    printf '%s[X] HATA: %s %s\n' "${RED}${BOLD}" "$1" "${NC}"
    echo "[$(date '+%F %T')] ERROR: $1" >> "$LOG_FILE"
}

print_warning() {
    if [[ "$QUIET_MODE" == "true" ]]; then
        echo "[$(date '+%F %T')] WARN: $1" >> "$LOG_FILE"
        return
    fi
    printf '%s[!] UYARI: %s %s\n' "${YELLOW}" "$1" "${NC}"
    echo "[$(date '+%F %T')] WARN: $1" >> "$LOG_FILE"
}

print_success() {
    if [[ "$QUIET_MODE" == "true" ]]; then
        echo "[$(date '+%F %T')] SUCCESS: $1" >> "$LOG_FILE"
        return
    fi
    printf '%s[+] %s %s\n' "${GREEN}${BOLD}" "$1" "${NC}"
    echo "[$(date '+%F %T')] SUCCESS: $1" >> "$LOG_FILE"
}

print_info() {
    if [[ "$QUIET_MODE" == "true" ]]; then
        echo "[$(date '+%F %T')] INFO: $1" >> "$LOG_FILE"
        return
    fi
    if [[ "$VERBOSE_MODE" == "true" ]]; then
        printf '%s[i] %s%s\n' "${BLUE}" "$1" "${NC}"
    fi
    echo "[$(date '+%F %T')] INFO: $1" >> "$LOG_FILE"
}

# --- v3.8.0: DRY-RUN MESAJI ---
print_dry_run() {
    printf '%s[DRY-RUN] %s%s\n' "${YELLOW}" "$1" "${NC}"
    echo "[$(date '+%F %T')] DRY-RUN: $1" >> "$LOG_FILE"
}

# --- SÄ°STEM BÄ°LGÄ°SÄ° BAÅžLIK KUTUSU ---
print_system_header() {
    local hostname_str
    hostname_str=$(hostname 2>/dev/null || echo "unknown")
    local user_str
    user_str=$(whoami 2>/dev/null || echo "unknown")
    local kernel_str
    kernel_str=$(uname -r 2>/dev/null || echo "unknown")
    local ram_str
    ram_str=$(free -h 2>/dev/null | awk '/^Mem:/{print $2}' || echo "N/A")
    local disk_str
    disk_str=$(df -h / 2>/dev/null | awk 'NR==2{print $5}' || echo "N/A")
    
    printf '%s========================================%s\n' "${GREEN}" "${NC}"
    printf '%s  ARCB-WIDER-UPDATER v%s%s\n' "${GREEN}" "${VERSION}" "${NC}"
    [[ "$DRY_RUN" == "true" ]] && printf '%s  [DRY-RUN MODE]%s\n' "${YELLOW}" "${NC}"
    printf '%s  Host: %s | User: %s%s\n' "${GREEN}" "${hostname_str}" "${user_str}" "${NC}"
    printf '%s  Kernel: %s%s\n' "${GREEN}" "${kernel_str}" "${NC}"
    printf '%s  RAM: %s | Disk: %s used%s\n' "${GREEN}" "${ram_str}" "${disk_str}" "${NC}"
    printf '%s========================================%s\n' "${GREEN}" "${NC}"
    
    # Log'a da yaz
    {
        echo "=================================================="
        echo "PRE-UPDATE SYSTEM INFO"
        echo "Version    : $VERSION ($CODENAME)"
        echo "Dry-Run    : $DRY_RUN"
        echo "Hostname   : $hostname_str"
        echo "User       : $user_str"
        echo "Kernel     : $kernel_str"
        echo "RAM        : $ram_str"
        echo "Disk Usage : $disk_str"
        echo "=================================================="
    } >> "$LOG_FILE"
}

# --- REBOOT GEREKLÄ° MÄ° KONTROLÃœ ---
check_reboot_required() {
    # Debian/Ubuntu: /var/run/reboot-required dosyasÄ±
    if [[ -f "/var/run/reboot-required" ]]; then
        echo "Gerekli"
        return
    fi
    
    # Fedora/RHEL: needs-restarting komutu
    if command -v needs-restarting &> /dev/null; then
        if ! needs-restarting -r &> /dev/null; then
            echo "Gerekli"
            return
        fi
    fi
    
    echo "Gerekli deÄŸil"
}

# --- FÄ°NAL Ã–ZET KUTUSU ---
print_final_summary() {
    local reboot_status
    reboot_status=$(check_reboot_required)
    
    # FIX: Ensure all counters are numeric - strip any non-numeric chars
    local apt_c dnf_c flatpak_c snap_c fwupd_c
    apt_c=$(echo "${APT_COUNT:-0}" | tr -cd '0-9')
    dnf_c=$(echo "${DNF_COUNT:-0}" | tr -cd '0-9')
    flatpak_c=$(echo "${FLATPAK_COUNT:-0}" | tr -cd '0-9')
    snap_c=$(echo "${SNAP_COUNT:-0}" | tr -cd '0-9')
    fwupd_c=$(echo "${FWUPD_COUNT:-0}" | tr -cd '0-9')
    
    # Default to 0 if empty after stripping
    apt_c=${apt_c:-0}
    dnf_c=${dnf_c:-0}
    flatpak_c=${flatpak_c:-0}
    snap_c=${snap_c:-0}
    fwupd_c=${fwupd_c:-0}
    
    local total_updates=$((apt_c + dnf_c + flatpak_c + snap_c + fwupd_c))
    
    echo ""
    printf '%s========================================%s\n' "${GREEN}" "${NC}"
    if [[ "$DRY_RUN" == "true" ]]; then
        printf '%s  [DRY-RUN] GÃœNCELLEME Ã–NÄ°ZLEMESÄ°%s\n' "${YELLOW}" "${NC}"
    else
        printf '%s  [+] GÃœNCELLEME TAMAMLANDI%s\n' "${GREEN}" "${NC}"
    fi
    printf '%s----------------------------------------%s\n' "${GREEN}" "${NC}"
    
    # APT veya DNF
    if command -v apt-get &> /dev/null; then
        if [[ $apt_c -gt 0 ]]; then
            printf '%s  APT: %s paket %s%s\n' "${GREEN}" "${apt_c}" "$([[ "$DRY_RUN" == "true" ]] && echo "gÃ¼ncellenebilir" || echo "gÃ¼ncellendi")" "${NC}"
        else
            printf '%s  APT: GÃ¼ncel%s\n' "${GREEN}" "${NC}"
        fi
    fi
    
    if command -v dnf &> /dev/null; then
        if [[ $dnf_c -gt 0 ]]; then
            printf '%s  DNF: %s paket %s%s\n' "${GREEN}" "${dnf_c}" "$([[ "$DRY_RUN" == "true" ]] && echo "gÃ¼ncellenebilir" || echo "gÃ¼ncellendi")" "${NC}"
        else
            printf '%s  DNF: GÃ¼ncel%s\n' "${GREEN}" "${NC}"
        fi
    fi
    
    # Flatpak
    if command -v flatpak &> /dev/null; then
        if [[ $flatpak_c -gt 0 ]]; then
            printf '%s  Flatpak: %s uygulama %s%s\n' "${GREEN}" "${flatpak_c}" "$([[ "$DRY_RUN" == "true" ]] && echo "gÃ¼ncellenebilir" || echo "gÃ¼ncellendi")" "${NC}"
        else
            printf '%s  Flatpak: GÃ¼ncel%s\n' "${GREEN}" "${NC}"
        fi
    fi
    
    # Snap
    if command -v snap &> /dev/null; then
        if [[ $snap_c -gt 0 ]]; then
            printf '%s  Snap: %s paket %s%s\n' "${GREEN}" "${snap_c}" "$([[ "$DRY_RUN" == "true" ]] && echo "gÃ¼ncellenebilir" || echo "gÃ¼ncellendi")" "${NC}"
        else
            printf '%s  Snap: GÃ¼ncel%s\n' "${GREEN}" "${NC}"
        fi
    fi
    
    # Firmware
    if command -v fwupdmgr &> /dev/null; then
        if [[ $fwupd_c -gt 0 ]]; then
            printf '%s  Firmware: %s %s%s\n' "${GREEN}" "${fwupd_c}" "$([[ "$DRY_RUN" == "true" ]] && echo "gÃ¼ncelleme mevcut" || echo "gÃ¼ncelleme")" "${NC}"
        else
            printf '%s  Firmware: GÃ¼ncel%s\n' "${GREEN}" "${NC}"
        fi
    fi
    
    printf '%s----------------------------------------%s\n' "${GREEN}" "${NC}"
    
    # Snapshot bilgisi
    if [[ -n "$SNAPSHOT_NAME" ]]; then
        printf '%s  Snapshot: %s%s\n' "${GREEN}" "${SNAPSHOT_NAME}" "${NC}"
    elif [[ "$DRY_RUN" == "true" ]]; then
        printf '%s  Snapshot: [DRY-RUN] OluÅŸturulmayacak%s\n' "${YELLOW}" "${NC}"
    else
        printf '%s  Snapshot: OluÅŸturulmadÄ±%s\n' "${GREEN}" "${NC}"
    fi
    
    # Reboot durumu
    if [[ "$reboot_status" == "Gerekli" ]]; then
        printf '%s  Reboot: [!] Gerekli%s\n' "${YELLOW}" "${NC}"
    else
        printf '%s  Reboot: Gerekli deÄŸil%s\n' "${GREEN}" "${NC}"
    fi
    
    # Log yolu
    printf '%s  Log: %s%s\n' "${BLUE}" "${LOG_FILE}" "${NC}"
    
    printf '%s========================================%s\n' "${GREEN}" "${NC}"
    
    # Log'a da yaz
    {
        echo "=================================================="
        echo "POST-UPDATE SUMMARY"
        echo "Dry-Run: $DRY_RUN"
        echo "Total Updates: $total_updates"
        [[ $apt_c -gt 0 ]] && echo "APT: $apt_c packages"
        [[ $dnf_c -gt 0 ]] && echo "DNF: $dnf_c packages"
        [[ $flatpak_c -gt 0 ]] && echo "Flatpak: $flatpak_c apps"
        [[ $snap_c -gt 0 ]] && echo "Snap: $snap_c packages"
        [[ $fwupd_c -gt 0 ]] && echo "Firmware: $fwupd_c updates"
        echo "Snapshot: ${SNAPSHOT_NAME:-None}"
        echo "Reboot Required: $reboot_status"
        echo "=================================================="
    } >> "$LOG_FILE"
}

setup_logging() {
    if [ ! -d "$LOG_DIR" ]; then
        mkdir -p "$LOG_DIR"
    fi
    
    local deleted_count
    # Logrotate handles log cleanup now
    # deleted_count=$(find "$LOG_DIR" -name "update_*.log" -type f -mtime +30 -print -delete | wc -l)
    deleted_count=0
    
    touch "$LOG_FILE"
    chmod 600 "$LOG_FILE"
    
    {
        echo "=================================================="
        echo "ARCB Wider Updater v$VERSION ($CODENAME)"
        echo "Start Time : $(date '+%F %T')"
        echo "User       : $(whoami)"
        echo "Hostname   : $(hostname)"
        echo "Mode       : $([[ "${AUTO_MODE:-false}" == "true" ]] && echo "AUTO" || echo "INTERACTIVE")"
        echo "Dry-Run    : $DRY_RUN"
        echo "Verbose    : $VERBOSE_MODE"
        echo "Quiet      : $QUIET_MODE"
        echo "Skip       : snapshot=$SKIP_SNAPSHOT flatpak=$SKIP_FLATPAK snap=$SKIP_SNAP fwupd=$SKIP_FWUPD dnf=$SKIP_DNF"
        echo "Only Mode  : ${ONLY_MODE:-none}"
        echo "=================================================="
        if [[ "$deleted_count" -gt 0 ]]; then
            echo "INFO: $deleted_count adet eski log dosyasÄ± temizlendi."
        fi
    } >> "$LOG_FILE"
}

download_file() {
    local url="$1"
    local output="$2"
    
    if command -v curl &> /dev/null; then
        curl -fsSL "$url" -o "$output"
    elif command -v wget &> /dev/null; then
        wget -qO "$output" "$url"
    else
        print_error "Sistemde 'curl' veya 'wget' bulunamadÄ±!"
        exit 1
    fi
}

check_connectivity() {
    if [[ "$QUIET_MODE" != "true" ]]; then
        printf '%s[~] BaÄŸlantÄ± kontrol ediliyor... %s' "${YELLOW}" "${NC}"
    fi
    local UA="Mozilla/5.0 (compat; ARCBUpdater/$VERSION)"
    
    local raw_ok=false
    if command -v curl &> /dev/null; then
        if curl -s -I -f -L -A "$UA" "$GITHUB_RAW_URL" > /dev/null; then raw_ok=true; fi
    elif command -v wget &> /dev/null; then
        if wget -q --spider --user-agent="$UA" "$GITHUB_RAW_URL"; then raw_ok=true; fi
    fi
    
    if [[ "$raw_ok" == "true" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            printf '%sBaÄŸlÄ±.%s\n' "${GREEN}" "${NC}"
        fi
        return 0
    else
        if [[ "$QUIET_MODE" != "true" ]]; then
            printf '%sKÄ±smi (Repo eriÅŸimi yok).%s\n' "${YELLOW}" "${NC}"
        fi
        print_warning "Repo dosyalarÄ±na eriÅŸilemiyor. Self-update devre dÄ±ÅŸÄ±."
        export SELF_UPDATE_DISABLED="true"
        return 0
    fi
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        printf '%s[*] Root yetkisi gerekiyor...%s\n' "${YELLOW}" "${NC}"
        if command -v sudo &> /dev/null; then
            # v3.6.1 FIX: Orijinal argÃ¼manlarÄ± kullan
            exec sudo -E "$0" "${ORIGINAL_ARGS[@]}"
        else
            print_error "Sudo yok ve root deÄŸilsin."
            exit 1
        fi
    fi
}

# --- YENÄ° v3.6.0: SHA256 DOÄžRULAMA Ä°LE SELF-UPDATE ---
check_self_update() {
    if [[ "${SELF_UPDATE_DISABLED:-false}" == "true" ]]; then return; fi
    if [[ "$DRY_RUN" == "true" ]]; then return; fi

    local REMOTE_FILE; REMOTE_FILE="$(mktemp /tmp/guncel_remote_XXXXXX)"
    local TEMP_SHA256; TEMP_SHA256="$(mktemp /tmp/guncel_sha256_XXXXXX)"
    local REMOTE_HASH
    local LOCAL_HASH
    
    # Cleanup on exit
    trap 'rm -f "$REMOTE_FILE" "$TEMP_SHA256"' RETURN
    
    if ! download_file "$GITHUB_RAW_URL" "$REMOTE_FILE"; then return; fi

    if ! grep -q "ARCB Wider Updater" "$REMOTE_FILE"; then
        rm -f "$REMOTE_FILE" "$TEMP_SHA256"
        return
    fi

    REMOTE_HASH=$(sha256sum "$REMOTE_FILE" | awk '{print $1}')
    LOCAL_HASH=$(sha256sum "$0" | awk '{print $1}')

    if [[ "$REMOTE_HASH" != "$LOCAL_HASH" && -n "$REMOTE_HASH" ]]; then
        printf '\n%s[!] Yeni sÃ¼rÃ¼m mevcut!%s\n' "${YELLOW}" "${NC}"
        
        # SHA256 doÄŸrulama (v3.6.0)
        if download_file "$GITHUB_SHA256_URL" "$TEMP_SHA256" 2>/dev/null; then
            local EXPECTED
            EXPECTED=$(grep "guncel" "$TEMP_SHA256" 2>/dev/null | awk '{print $1}')
            if [[ -n "$EXPECTED" && "$EXPECTED" != "$REMOTE_HASH" ]]; then
                print_error "SHA256 doÄŸrulama baÅŸarÄ±sÄ±z! GÃ¼ncelleme iptal edildi."
                echo "[$(date '+%F %T')] ERROR: SHA256 mismatch - Expected: $EXPECTED, Got: $REMOTE_HASH" >> "$LOG_FILE"
                return 1
            fi
            if [[ -n "$EXPECTED" ]]; then
                print_info "SHA256 doÄŸrulama baÅŸarÄ±lÄ±."
            fi
        else
            print_warning "SHA256SUMS dosyasÄ± bulunamadÄ±, doÄŸrulama atlanÄ±yor."
        fi
        
        if [[ "${AUTO_MODE:-false}" == "true" ]]; then
             REPLY="e"
        else
             read -p "   GÃ¼ncellemek ister misin? (e/H): " -n 1 -r
             echo
        fi

        if [[ ${REPLY:-H} =~ ^[Ee]$ ]]; then
            print_header "Self-Update BaÅŸlatÄ±lÄ±yor..."
            
            # v3.6.0: .bak yedek mekanizmasÄ±
            if [ -f "$0" ]; then
                if cp "$0" "${0}.bak"; then
                    print_info "Eski sÃ¼rÃ¼m yedeklendi: ${0}.bak"
                else
                    print_warning "Yedek oluÅŸturulamadÄ±, devam ediliyor."
                fi
            fi
            
            if install -m 0755 "$REMOTE_FILE" "$0"; then
                print_success "Script gÃ¼ncellendi. Yeniden baÅŸlatÄ±lÄ±yor..."
                exec "$0" "${ORIGINAL_ARGS[@]}"
            else
                print_error "GÃ¼ncelleme kopyalanamadÄ±!"
                # Rollback attempt
                if [ -f "${0}.bak" ]; then
                    print_warning "Yedekten geri yÃ¼kleme deneniyor..."
                    cp "${0}.bak" "$0" && print_success "Geri yÃ¼kleme baÅŸarÄ±lÄ±."
                fi
                exit 1
            fi
        fi
    fi
    rm -f "$REMOTE_FILE" "$TEMP_SHA256"
}

wait_for_lock() {
    local has_checker="false"
    if command -v fuser &> /dev/null; then has_checker="fuser";
    elif command -v lsof &> /dev/null; then has_checker="lsof"; fi

    if [[ "$has_checker" == "false" ]]; then return; fi

    local max_retries=15
    local count=0
    local lock_files=("/var/lib/dpkg/lock" "/var/lib/dpkg/lock-frontend" "/var/lib/apt/lists/lock" "/var/cache/apt/archives/lock")
    
    while true; do
        local locked=false
        for lock in "${lock_files[@]}"; do
            if [[ "$has_checker" == "fuser" ]]; then
                if fuser "$lock" >/dev/null 2>&1; then locked=true; break; fi
            elif [[ "$has_checker" == "lsof" ]]; then
                if lsof "$lock" >/dev/null 2>&1; then locked=true; break; fi
            fi
        done

        if [[ "$locked" == "false" ]]; then break; fi

        if [ $count -ge $max_retries ]; then
            print_error "APT kilitleri kaldÄ±rÄ±lamadÄ±. Manuel mÃ¼dahale gerek."
            exit 1
        fi
        
        printf '%s[~] APT kilitli (%s), bekleniyor... (%s/%s)%s\n' "${YELLOW}" "$has_checker" "$count" "$max_retries" "${NC}"
        sleep 5
        ((count++))
    done
}

wait_for_dnf_lock() {
    local max_attempts=30
    local attempt=0
    while [ $attempt -lt $max_attempts ]; do
        if ! pgrep -x "dnf|yum|rpm" > /dev/null 2>&1; then
            return 0
        fi
        print_warning "DNF kilidi bekleniyor... ($((attempt+1))/$max_attempts)"
        sleep 10
        ((attempt++))
    done
    print_error "DNF kilidi zaman aÅŸÄ±mÄ±!"
    return 1
}

create_snapshot() {
    # v3.6.0: --skip snapshot kontrolÃ¼
    if [[ "$SKIP_SNAPSHOT" == "true" ]]; then
        print_info "Snapshot atlandÄ± (--skip snapshot)"
        return
    fi
    
    # v3.6.0: --only kontrolÃ¼ (system veya fwupd ise snapshot atla)
    if [[ -n "$ONLY_MODE" && "$ONLY_MODE" != "snapshot" ]]; then
        return
    fi
    
    # v3.8.0: Dry-run modunda snapshot oluÅŸturma
    if [[ "$DRY_RUN" == "true" ]]; then
        if command -v timeshift &> /dev/null; then
            print_dry_run "Timeshift snapshot oluÅŸturulacak: ARCB-Update-$(date +%F)"
        elif command -v snapper &> /dev/null; then
            print_dry_run "Snapper snapshot oluÅŸturulacak: ARCB-Update-$(date +%F)"
        else
            print_dry_run "Yedekleme aracÄ± (Timeshift/Snapper) bulunamadÄ±"
        fi
        return
    fi
    
    if command -v timeshift &> /dev/null; then
        print_header "Sistem Yedekleniyor (Timeshift)"
        SNAPSHOT_NAME="ARCB-Update-$(date +%F)"
        if [[ "$VERBOSE_MODE" == "true" ]]; then
            timeshift --create --comments "$SNAPSHOT_NAME" --tags D 2>&1 | tee -a "$LOG_FILE"
        else
            timeshift --create --comments "$SNAPSHOT_NAME" --tags D >> "$LOG_FILE" 2>&1
            print_success "Timeshift snapshot oluÅŸturuldu."
        fi
        return
    fi

    if command -v snapper &> /dev/null; then
        print_header "Sistem Yedekleniyor (Snapper)"
        SNAPSHOT_NAME="ARCB-Update-$(date +%F)"
        if snapper create --description "$SNAPSHOT_NAME" --cleanup-algorithm number >> "$LOG_FILE" 2>&1; then
             print_success "Snapper snapshot oluÅŸturuldu."
        else
             print_warning "Snapper snapshot oluÅŸturulamadÄ±."
             SNAPSHOT_NAME=""
        fi
        return
    fi
    
    if [[ "${AUTO_MODE:-false}" != "true" ]]; then
         echo "[$(date '+%F %T')] INFO: Yedekleme aracÄ± (Timeshift/Snapper) yok." >> "$LOG_FILE"
    fi
}

# --- YENÄ° v3.6.0: ONLY MODE KONTROLÃœ ---
should_run_backend() {
    local backend="$1"
    
    # EÄŸer --only belirtilmiÅŸse, sadece o backend Ã§alÄ±ÅŸsÄ±n
    if [[ -n "$ONLY_MODE" ]]; then
        IFS=',' read -ra ONLY_ITEMS <<< "$ONLY_MODE"
        for item in "${ONLY_ITEMS[@]}"; do
            if [[ "$item" == "$backend" || "$item" == "system" && ("$backend" == "apt" || "$backend" == "dnf") ]]; then
                return 0
            fi
        done
        return 1
    fi
    
    return 0
}

# --- v3.8.0: DRY-RUN GÃœNCELLEME LÄ°STELEME ---
perform_dry_run_check() {
    print_header "[DRY-RUN] Mevcut GÃ¼ncellemeler Kontrol Ediliyor"
    
    # APT
    if command -v apt-get &> /dev/null && [[ "$SKIP_DNF" != "true" ]] && should_run_backend "apt"; then
        print_dry_run "APT: GÃ¼ncellenebilir paketler listeleniyor..."
        printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
        apt-get update -qq >> "$LOG_FILE" 2>&1 || true
        local apt_list
        apt_list=$(apt list --upgradable 2>/dev/null | grep -v "Listing..." || true)
        if [[ -n "$apt_list" ]]; then
            echo "$apt_list"
            APT_COUNT=$(echo "$apt_list" | wc -l | tr -cd '0-9')
        else
            printf '%s  TÃ¼m paketler gÃ¼ncel.%s\n' "${GREEN}" "${NC}"
            APT_COUNT=0
        fi
        echo ""
    fi
    
    # DNF
    if command -v dnf &> /dev/null && [[ "$SKIP_DNF" != "true" ]] && should_run_backend "dnf"; then
        print_dry_run "DNF: GÃ¼ncellenebilir paketler listeleniyor..."
        printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
        local dnf_list
        dnf_list=$(dnf check-update 2>/dev/null | grep -v "^$" | grep -v "Last metadata" || true)
        if [[ -n "$dnf_list" ]]; then
            echo "$dnf_list"
            DNF_COUNT=$(echo "$dnf_list" | wc -l | tr -cd '0-9')
        else
            printf '%s  TÃ¼m paketler gÃ¼ncel.%s\n' "${GREEN}" "${NC}"
            DNF_COUNT=0
        fi
        echo ""
    fi
    
    # Flatpak
    if command -v flatpak &> /dev/null && [[ "$SKIP_FLATPAK" != "true" ]] && should_run_backend "flatpak"; then
        print_dry_run "Flatpak: GÃ¼ncellenebilir uygulamalar listeleniyor..."
        printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
        local flatpak_list
        flatpak_list=$(flatpak remote-ls --updates 2>/dev/null || true)
        if [[ -n "$flatpak_list" ]]; then
            echo "$flatpak_list"
            FLATPAK_COUNT=$(echo "$flatpak_list" | wc -l | tr -cd '0-9')
        else
            printf '%s  TÃ¼m uygulamalar gÃ¼ncel.%s\n' "${GREEN}" "${NC}"
            FLATPAK_COUNT=0
        fi
        echo ""
    fi
    
    # Snap
    if command -v snap &> /dev/null && [[ "$SKIP_SNAP" != "true" ]] && should_run_backend "snap"; then
        print_dry_run "Snap: GÃ¼ncellenebilir paketler listeleniyor..."
        printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
        local snap_list
        snap_list=$(snap refresh --list 2>/dev/null | tail -n +2 || true)
        if [[ -n "$snap_list" ]]; then
            echo "$snap_list"
            SNAP_COUNT=$(echo "$snap_list" | wc -l | tr -cd '0-9')
        else
            printf '%s  TÃ¼m paketler gÃ¼ncel.%s\n' "${GREEN}" "${NC}"
            SNAP_COUNT=0
        fi
        echo ""
    fi
    
    # Firmware - v3.8.1 FIX: "No updatable devices" durumunda exit 0
    if command -v fwupdmgr &> /dev/null && [[ "$SKIP_FWUPD" != "true" ]] && should_run_backend "fwupd"; then
        print_dry_run "Firmware: Mevcut gÃ¼ncellemeler kontrol ediliyor..."
        printf '%s--------------------------------------------------%s\n' "${BLUE}" "${NC}"
        fwupdmgr refresh --force >> "$LOG_FILE" 2>&1 || true
        local fwupd_list fwupd_exit_code
        fwupd_list=$(fwupdmgr get-updates 2>&1) || fwupd_exit_code=$?
        # fwupdmgr returns exit code 2 for "No updatable devices" - this is not an error
        if [[ -n "$fwupd_list" && ! "$fwupd_list" =~ "No upgrades" && ! "$fwupd_list" =~ "No updatable devices" ]]; then
            echo "$fwupd_list"
            FWUPD_COUNT=$(echo "$fwupd_list" | grep -c "New version" | tr -cd '0-9' || echo "0")
        else
            printf '%s  Firmware gÃ¼ncel.%s\n' "${GREEN}" "${NC}"
            FWUPD_COUNT=0
        fi
        echo ""
    fi
}

perform_updates() {
    # v3.8.0: Dry-run modunda sadece listele
    if [[ "$DRY_RUN" == "true" ]]; then
        perform_dry_run_check
        return
    fi
    
    local apt_opts=()
    if [[ "${AUTO_MODE:-false}" == "true" ]]; then
        export DEBIAN_FRONTEND=noninteractive
        apt_opts=(-o "Dpkg::Options::=--force-confdef" -o "Dpkg::Options::=--force-confold")
    fi

    # APT GÃ¼ncellemesi
    if command -v apt-get &> /dev/null && [[ "$SKIP_DNF" != "true" ]] && should_run_backend "apt"; then
        wait_for_lock
        print_header "APT: GÃ¼ncelleme BaÅŸlÄ±yor"
        
        if [[ "$VERBOSE_MODE" == "true" ]]; then
            apt-get update 2>&1 | tee -a "$LOG_FILE"
        else
            apt-get update >> "$LOG_FILE" 2>&1
        fi
        
        print_header "APT: Dist-Upgrade"
        local apt_upgradable
        apt_upgradable=$(apt-get -s dist-upgrade 2>/dev/null | grep -c "^Inst " || echo "0")
        APT_COUNT=${apt_upgradable:-0}
        
        if [[ "$VERBOSE_MODE" == "true" ]]; then
            apt-get dist-upgrade -y "${apt_opts[@]}" 2>&1 | tee -a "$LOG_FILE"
        else
            apt-get dist-upgrade -y "${apt_opts[@]}" >> "$LOG_FILE" 2>&1
        fi
        
        print_header "APT: Temizlik"
        if [[ "$VERBOSE_MODE" == "true" ]]; then
            apt-get autoremove -y "${apt_opts[@]}" 2>&1 | tee -a "$LOG_FILE"
            apt-get autoclean -y "${apt_opts[@]}" 2>&1 | tee -a "$LOG_FILE"
        else
            apt-get autoremove -y "${apt_opts[@]}" >> "$LOG_FILE" 2>&1
            apt-get autoclean -y "${apt_opts[@]}" >> "$LOG_FILE" 2>&1
        fi
        
        print_info "APT: $APT_COUNT paket gÃ¼ncellendi."

    elif command -v dnf &> /dev/null && [[ "$SKIP_DNF" != "true" ]] && should_run_backend "dnf"; then
        if ! wait_for_dnf_lock; then
            print_error "DNF kilidi alÄ±namadÄ±, DNF gÃ¼ncellemesi atlanÄ±yor."
        else
            print_header "DNF: GÃ¼ncelleme"
            
            # v3.6.1 FIX: DNF sayacÄ±nÄ± gÃ¼ncelleme Ã§Ä±ktÄ±sÄ±ndan al
            local dnf_temp
            dnf_temp=$(mktemp)
            
            if [[ "$VERBOSE_MODE" == "true" ]]; then
                dnf upgrade --refresh -y 2>&1 | tee -a "$LOG_FILE" | tee "$dnf_temp"
            else
                dnf upgrade --refresh -y 2>&1 | tee "$dnf_temp" >> "$LOG_FILE"
            fi
            
            # v3.6.1 FIX: Parse DNF output for actual upgraded count
            # Look for "Upgrading:" line in Transaction Summary or count upgraded packages
            DNF_COUNT=$(grep -E "^Upgrading:" "$dnf_temp" 2>/dev/null | grep -oP '\d+' | head -1 || echo "0")
            if [[ -z "$DNF_COUNT" || "$DNF_COUNT" == "0" ]]; then
                # Alternative: count "Upgrading <package>" lines
                DNF_COUNT=$(grep -cE "^\s*Upgrading\s+[a-zA-Z]" "$dnf_temp" 2>/dev/null || echo "0")
            fi
            if [[ -z "$DNF_COUNT" || "$DNF_COUNT" == "0" ]]; then
                # Alternative: look for "Upgraded:" in summary
                DNF_COUNT=$(grep -oP "Upgraded:\s*\K\d+" "$dnf_temp" 2>/dev/null || echo "0")
            fi
            if [[ -z "$DNF_COUNT" || "$DNF_COUNT" == "0" ]]; then
                # Alternative: count lines with version upgrade pattern (x.x.x -> y.y.y)
                DNF_COUNT=$(grep -cE "â†’|->|\s+[0-9]+\.[0-9]+.*\s+[0-9]+\.[0-9]+" "$dnf_temp" 2>/dev/null || echo "0")
            fi
            
            rm -f "$dnf_temp"
            DNF_COUNT=${DNF_COUNT:-0}
            
            print_info "DNF: $DNF_COUNT paket gÃ¼ncellendi."
        fi
    fi

    # Flatpak GÃ¼ncellemesi
    if command -v flatpak &> /dev/null && [[ "$SKIP_FLATPAK" != "true" ]] && should_run_backend "flatpak"; then
        print_header "Flatpak: GÃ¼ncelleme"
        
        # v3.6.1 FIX: Flatpak sayacÄ±nÄ± gÃ¼ncelleme Ã–NCE al
        local flatpak_upgradable
        flatpak_upgradable=$(flatpak remote-ls --updates 2>/dev/null | wc -l | tr -cd '0-9')
        flatpak_upgradable=${flatpak_upgradable:-0}
        
        local flatpak_temp
        flatpak_temp=$(mktemp)
        
        if [[ "$VERBOSE_MODE" == "true" ]]; then
            flatpak update -y 2>&1 | tee -a "$LOG_FILE" | tee "$flatpak_temp" || print_warning "Flatpak hata verdi."
            flatpak uninstall --unused -y 2>&1 | tee -a "$LOG_FILE" || true
        else
            flatpak update -y 2>&1 | tee "$flatpak_temp" >> "$LOG_FILE" || print_warning "Flatpak hata verdi."
            flatpak uninstall --unused -y >> "$LOG_FILE" 2>&1 || true
        fi
        
        # v3.6.1 FIX: Check if "Nothing to do" in output - means no updates
        if grep -qi "Nothing to do" "$flatpak_temp" 2>/dev/null; then
            FLATPAK_COUNT=0
        else
            # Count actual updates from output or use pre-count
            local flatpak_updated
            flatpak_updated=$(grep -cE "^[0-9]+\.\s" "$flatpak_temp" 2>/dev/null | tr -cd '0-9')
            flatpak_updated=${flatpak_updated:-0}
            if [[ "$flatpak_updated" -gt 0 ]]; then
                FLATPAK_COUNT=$flatpak_updated
            else
                FLATPAK_COUNT=${flatpak_upgradable:-0}
            fi
        fi
        
        rm -f "$flatpak_temp"
        
        print_info "Flatpak: $FLATPAK_COUNT uygulama gÃ¼ncellendi."
    fi

    # Snap GÃ¼ncellemesi
    if command -v snap &> /dev/null && [[ "$SKIP_SNAP" != "true" ]] && should_run_backend "snap"; then
        print_header "Snap: GÃ¼ncelleme"
        
        local snap_upgradable
        snap_upgradable=$(snap refresh --list 2>/dev/null | tail -n +2 | wc -l | tr -cd '0-9')
        snap_upgradable=${snap_upgradable:-0}
        SNAP_COUNT=${snap_upgradable:-0}
        
        if [[ "$VERBOSE_MODE" == "true" ]]; then
            snap refresh 2>&1 | tee -a "$LOG_FILE" || print_warning "Snap hata verdi."
        else
            snap refresh >> "$LOG_FILE" 2>&1 || print_warning "Snap hata verdi."
        fi
        
        print_info "Snap: $SNAP_COUNT paket gÃ¼ncellendi."
    fi
    
    # Firmware GÃ¼ncellemesi - v3.8.1 FIX: "No updatable devices" durumunda exit 0
    if command -v fwupdmgr &> /dev/null && [[ "$SKIP_FWUPD" != "true" ]] && should_run_backend "fwupd"; then
        print_header "Firmware: Kontrol"
        
        local fwupd_output fwupd_exit_code=0
        fwupd_output=$(fwupdmgr get-updates 2>&1) || fwupd_exit_code=$?
        
        # fwupdmgr returns exit code 2 for "No updatable devices" - this is not an error
        if [[ $fwupd_exit_code -eq 2 ]] || [[ "$fwupd_output" =~ "No updatable devices" ]]; then
            print_info "Firmware: GÃ¼ncellenebilir cihaz bulunamadÄ±."
            FWUPD_COUNT=0
        elif [[ $fwupd_exit_code -ne 0 ]]; then
            print_warning "Firmware kontrolÃ¼ baÅŸarÄ±sÄ±z (exit code: $fwupd_exit_code)"
            FWUPD_COUNT=0
        else
            local fwupd_upgradable
            fwupd_upgradable=$(echo "$fwupd_output" | grep -c "New version" | tr -cd '0-9' || echo "0")
            fwupd_upgradable=${fwupd_upgradable:-0}
            FWUPD_COUNT=${fwupd_upgradable:-0}
            
            if [[ "${AUTO_MODE:-false}" == "true" ]]; then
                { fwupdmgr refresh --force || true; fwupdmgr update -y || true; } >> "$LOG_FILE" 2>&1
                if [[ "$QUIET_MODE" != "true" ]]; then
                    printf '%sTamamlandÄ± (Detaylar log dosyasÄ±nda).%s\n' "${GREEN}" "${NC}"
                fi
            else
                if [[ "$VERBOSE_MODE" == "true" ]]; then
                    fwupdmgr refresh --force 2>&1 | tee -a "$LOG_FILE" || true
                    fwupdmgr update -y 2>&1 | tee -a "$LOG_FILE" || true
                else
                    fwupdmgr refresh --force >> "$LOG_FILE" 2>&1 || true
                    fwupdmgr update -y >> "$LOG_FILE" 2>&1 || true
                fi
            fi
        fi
        
        print_info "Firmware: $FWUPD_COUNT gÃ¼ncelleme."
    fi
}

show_help() {
    printf '%sARCB Wider Updater v%s (%s)%s\n' "${BOLD}" "$VERSION" "$CODENAME" "${NC}"
    echo "--------------------------------------------------"
    echo "KullanÄ±m: guncel [SEÃ‡ENEK]"
    echo ""
    echo "SeÃ§enekler:"
    echo "  --auto              Otomatik mod (Onay sormadan gÃ¼nceller)"
    echo "  --verbose           DetaylÄ± Ã§Ä±ktÄ± modu (TÃ¼m komut Ã§Ä±ktÄ±larÄ±nÄ± gÃ¶sterir)"
    echo "  --quiet             Sessiz mod (Sadece hata ve Ã¶zet gÃ¶sterir)"
    echo "  --dry-run           Kuru Ã§alÄ±ÅŸtÄ±rma (Ne yapÄ±lacaÄŸÄ±nÄ± gÃ¶ster, yapma)"
    echo "  --skip <backend>    Belirtilen backend'leri atla (virgÃ¼lle ayÄ±r)"
    echo "                      DeÄŸerler: snapshot, flatpak, snap, fwupd, dnf, apt"
    echo "  --only <backend>    Sadece belirtilen backend'leri Ã§alÄ±ÅŸtÄ±r (virgÃ¼lle ayÄ±r)"
    echo "                      DeÄŸerler: system, flatpak, snap, fwupd, dnf, apt"
    echo "  --help              Bu yardÄ±m mesajÄ±nÄ± gÃ¶sterir"
    echo ""
    echo "Ã–rnekler:"
    echo "  guncel                        -> Ä°nteraktif (Ã–nerilen)"
    echo "  guncel --auto                 -> Cron / ZamanlanmÄ±ÅŸ gÃ¶revler"
    echo "  guncel --verbose              -> DetaylÄ± Ã§Ä±ktÄ± ile gÃ¼ncelleme"
    echo "  guncel --quiet                -> Sessiz gÃ¼ncelleme (sadece Ã¶zet)"
    echo "  guncel --dry-run              -> GÃ¼ncellemeleri listele (uygulamadan)"
    echo "  guncel --skip flatpak,snap    -> Flatpak ve Snap atla"
    echo "  guncel --only system          -> Sadece sistem paketleri (APT/DNF)"
    echo "  guncel --only flatpak,fwupd   -> Sadece Flatpak ve Firmware"
    echo ""
    echo "Config DosyasÄ±: $CONFIG_FILE"
    echo "  VarsayÄ±lan ayarlarÄ± config dosyasÄ±nda tanÄ±mlayabilirsiniz."
    echo "  Ã–rnek: /etc/arcb-wider-updater.conf.example"
    exit 0
}

# --- ARGUMENT PARSING ---
while [[ $# -gt 0 ]]; do
    case $1 in
        --auto) AUTO_MODE="true"; shift ;;
        --verbose) VERBOSE_MODE="true"; shift ;;
        --quiet) QUIET_MODE="true"; shift ;;
        --dry-run) DRY_RUN="true"; shift ;;
        --skip)
            if [[ -n "${2:-}" && ! "$2" =~ ^-- ]]; then
                IFS=',' read -ra SKIP_ITEMS <<< "$2"
                for item in "${SKIP_ITEMS[@]}"; do
                    case "$item" in
                        snapshot) SKIP_SNAPSHOT=true ;;
                        flatpak) SKIP_FLATPAK=true ;;
                        snap) SKIP_SNAP=true ;;
                        fwupd) SKIP_FWUPD=true ;;
                        dnf|apt|system) SKIP_DNF=true ;;
                        *) printf '%sUyarÄ±: Bilinmeyen skip deÄŸeri: %s%s\n' "${YELLOW}" "$item" "${NC}" ;;
                    esac
                done
                shift 2
            else
                printf '%sHATA: --skip iÃ§in deÄŸer gerekli (Ã¶rn: --skip flatpak,snap)%s\n' "${RED}" "${NC}"
                exit 1
            fi
            ;;
        --only)
            if [[ -n "${2:-}" && ! "$2" =~ ^-- ]]; then
                ONLY_MODE="$2"
                shift 2
            else
                printf '%sHATA: --only iÃ§in deÄŸer gerekli (Ã¶rn: --only system)%s\n' "${RED}" "${NC}"
                exit 1
            fi
            ;;
        --help) show_help ;;
        *) printf '%sUyarÄ±: Bilinmeyen argÃ¼man: %s%s\n' "${YELLOW}" "$1" "${NC}"; shift ;;
    esac
done

# Verbose ve quiet aynÄ± anda kullanÄ±lamaz
if [[ "$VERBOSE_MODE" == "true" && "$QUIET_MODE" == "true" ]]; then
    printf '%sHATA: --verbose ve --quiet aynÄ± anda kullanÄ±lamaz.%s\n' "${RED}" "${NC}"
    exit 1
fi

check_root

# --- FLOCK: EÅŸzamanlÄ± Ã§alÄ±ÅŸma kilidi ---
LOCK_FILE="/var/lock/arcb-wider-updater.lock"
exec 9>"$LOCK_FILE"
if ! flock -n 9; then
    print_error "BaÅŸka bir gÃ¼ncelleme iÅŸlemi zaten Ã§alÄ±ÅŸÄ±yor."
    exit 1
fi
setup_logging

if ! check_connectivity; then
    print_error "Ä°nternet baÄŸlantÄ±sÄ± kurulamadÄ±. Ä°ÅŸlem iptal."
    exit 1
fi

check_self_update

if [[ "$AUTO_MODE" != "true" && "$QUIET_MODE" != "true" ]]; then clear; fi

# BaÅŸlangÄ±Ã§ Ã¶zeti
print_system_header

if [[ "$QUIET_MODE" != "true" ]]; then
    printf '%s   Log: %s%s\n' "${BLUE}" "$LOG_FILE" "${NC}"
    printf '%s   Mod: %s%s\n' "${BLUE}" "$( [[ "$AUTO_MODE" == "true" ]] && echo "Otomatik ðŸ¤–" || echo "Ä°nteraktif ðŸ‘¤" )" "${NC}"
    [[ "$VERBOSE_MODE" == "true" ]] && printf '%s   Verbose: Aktif%s\n' "${BLUE}" "${NC}"
    [[ "$DRY_RUN" == "true" ]] && printf '%s   Dry-Run: Aktif (DeÄŸiÅŸiklik yapÄ±lmayacak)%s\n' "${YELLOW}" "${NC}"
    [[ -n "$ONLY_MODE" ]] && printf '%s   Only: %s%s\n' "${BLUE}" "$ONLY_MODE" "${NC}"
    echo ""
fi

create_snapshot
perform_updates

# BitiÅŸ Ã¶zeti
print_final_summary
